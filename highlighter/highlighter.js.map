{"version":3,"file":"highlighter.js","mappings":"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","sources":["webpack://highlighter/webpack/universalModuleDefinition","webpack://highlighter/./src/core.js","webpack://highlighter/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://highlighter/./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://highlighter/./node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://highlighter/./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://highlighter/./src/dom/classes.js","webpack://highlighter/./src/dom/index.js","webpack://highlighter/./src/highlighter/characterRange.js","webpack://highlighter/./src/utils/index.js","webpack://highlighter/./src/utils/toType.js","webpack://highlighter/./src/utils/trie.js","webpack://highlighter/./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack://highlighter/./node_modules/@babel/runtime/helpers/esm/classCallCheck.js","webpack://highlighter/./node_modules/@babel/runtime/helpers/esm/createClass.js","webpack://highlighter/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://highlighter/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://highlighter/./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack://highlighter/webpack/bootstrap","webpack://highlighter/webpack/runtime/define property getters","webpack://highlighter/webpack/runtime/hasOwnProperty shorthand","webpack://highlighter/./src/refills/index.js","webpack://highlighter/./src/highlighter/highlight.js","webpack://highlighter/./src/highlighter/eventEmitter.js","webpack://highlighter/./src/highlighter/index.js","webpack://highlighter/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Highlighter\"] = factory();\n\telse\n\t\troot[\"Highlighter\"] = factory();\n})(this, function() {\nreturn ","'use strict'\n\nimport { isCharacterDataNode, getNodeIndex, getNodeLength, findClosestAncestor, insertPoint, iterateSubtree, isOrIsAncestorOf } from '@/dom';\nimport { extend } from '@/utils';\n\nconst core = {};\n\n/**\n *\n * @param {Range} range\n */\nfunction splitRangeBoundaries (range) {\n  let [sc, so, ec, eo] = [range.startContainer, range.startOffset, range.endContainer, range.endOffset];\n\n  const startSameEnd = (sc === ec);\n  if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n    ec.splitText(eo);\n  }\n\n  if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n    sc = sc.splitText(so);\n    if (startSameEnd) {\n      eo -= so;\n      ec = sc;\n    } else if (ec === sc.parentNode && eo <= getNodeIndex(sc)) {\n      eo++;\n    }\n    so = 0;\n  }\n\n  setRange(range, sc, so, ec, eo);\n}\n\n/**\n *\n * @param {Range} range\n */\nfunction setRange (range) {\n  let sc = arguments[1], so = arguments[2], ec, eo;\n  const len = getNodeLength(sc);\n\n  switch (arguments.length) {\n    case 3:\n      ec = sc;\n      eo = len;\n      break;\n    case 4:\n      ec = arguments[3];\n      eo = so;\n      break;\n    case 5:\n      ec = arguments[3];\n      eo = arguments[4];\n      break;\n  }\n\n  range.setStart(sc, so);\n  range.setEnd(ec, eo);\n}\n\n/**\n *\n * @param {Range} range\n * @param {Node} node\n */\nfunction insertNode (range, node) {\n  let nodes = [];\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    nodes = node.childNodes;\n  } else {\n    nodes = [node];\n  }\n\n  let firstNode;\n  for (let i = nodes.length, n; (n = nodes[--i]);) {\n    firstNode = insertPoint(n, range.startContainer, range.startOffset);\n  }\n\n  if (firstNode) {\n    range.setStartBefore(firstNode);\n  }\n}\n\nclass RangeIterator {\n  /**\n   *\n   * @param {Range} range\n   * @param {boolean} clonePartiallySelectedTextNodes\n   */\n  constructor(range, clonePartiallySelectedTextNodes) {\n    this.range = range;\n    this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n    if (!this.range.collapsed) {\n      this.root = this.range.commonAncestorContainer;\n      this.sc = this.range.startContainer;\n      this.so = this.range.startOffset;\n      this.ec = this.range.endContainer;\n      this.eo = this.range.endOffset;\n\n      if (this.sc === this.ec && isCharacterDataNode(this.sc)) {\n        this._next = this._end = this.sc;\n      } else {\n        this._next = this.sc === this.root && !isCharacterDataNode(this.sc)\n          ? this.sc.childNodes[this.so] : findClosestAncestor(this.root, this.sc)\n\n        this._end = this.ec === this.root && !isCharacterDataNode(this.ec)\n          ? this.ec.childNodes[this.eo - 1] : findClosestAncestor(this.root, this.ec);\n      }\n    }\n\n  }\n\n  _current = null;\n  _end = null;\n  _next = null;\n\n  next () {\n    let current = this._current = this._next;\n    this._next = this._current != null && this._current !== this._end ? this._current.nextSibling : null;\n\n    // Check for partially selected text nodes\n    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n      // clone partially selected text nodes\n      // return cloneNode\n      if (current === this.ec) {\n        (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n      }\n\n      if (current === this.sc) {\n        (current = current.cloneNode(true)).deleteData(0, this.so);\n      }\n    }\n\n    return current;\n  }\n\n  isPartiallySelectedSubtree () {\n    return !isCharacterDataNode(this._current) &&\n      (isOrIsAncestorOf(this._current, this.sc) || isOrIsAncestorOf(this._current, this.ec));\n  }\n\n  getSubtreeIterator () {\n    const range = document.createRange(), current = this._current;\n    let startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);\n\n    if (isOrIsAncestorOf(current, this.sc)) {\n      startContainer = this.sc;\n      startOffset = this.so;\n    }\n    if (isOrIsAncestorOf(current, this.ec)) {\n      endContainer = this.ec;\n      endOffset = this.eo;\n    }\n\n    setRange(range, startContainer, startOffset, endContainer, endOffset);\n\n    return new RangeIterator(range, this.clonePartiallySelectedTextNodes);\n  }\n}\n\n\n/**\n *\n * @param {Range} range\n * @param {number[]} [nodeTypes]\n * @param {(node: Node) => boolean} [filter]\n * @return {Node[]}\n */\nfunction getNodes (range, nodeTypes, filter) {\n  let nodes = [], regx;\n  if (nodeTypes && nodeTypes.length) {\n    regx = new RegExp(`(${nodeTypes.join('|')})$`);\n  }\n\n  iterateSubtree(new RangeIterator(range, false), (node) => {\n    if (regx && !regx.test(node.nodeType)) {\n      return;\n    }\n\n    if (typeof filter == 'function' && !filter(node)) {\n      return;\n    }\n\n    nodes.push(node);\n  });\n\n  return nodes;\n}\n\n/**\n * range (prev/next) point (last/first)\n * @param {Range} range\n * @return {Node[]}\n */\nfunction getEffectiveTextNodes (range) {\n\n  const textNodes = getNodes(range, [Node.TEXT_NODE]);\n  let start = 0, end = textNodes.length, node;\n\n  // remove invalid text nodes from left to right\n  while ((node = textNodes[start]) && !rangeSelectsAnyText(range, node)) {\n    ++start;\n  }\n\n  // remove invalid text nodes from right to left\n  while ((node = textNodes[end - 1]) && !rangeSelectsAnyText(range, node)) {\n    --end;\n  }\n\n  return textNodes.slice(start, end);\n}\n\n/**\n * Exclude empty strings selected by the range\n * @param {Range} range\n * @param {Text} textNode\n * @return {boolean}\n */\nfunction rangeSelectsAnyText(range, textNode) {\n  const textNodeRange = document.createRange();\n  textNodeRange.selectNodeContents(textNode);\n  const intersectionRange = getIntersectionRange(textNodeRange, range);\n  const text = intersectionRange ? intersectionRange.toString() : '';\n  return text !== '';\n}\n\n/**\n * Returns a boolean indicating whether the given Range intersects the Range.\n * @param {Range} rangeA\n * @param {Range} rangeB\n * @return {boolean}\n */\nfunction intersectsRange (rangeA, rangeB) {\n  // rangeA.s < rangeB.e;\n  const start = rangeA.compareBoundaryPoints(rangeB.END_TO_START, rangeB);\n  // rangeA.e > rangeB.s;\n  const end = rangeA.compareBoundaryPoints(rangeB.START_TO_END, rangeB);\n\n  return start < 0 && end > 0;\n}\n\n/**\n * Returns the part of a specified range that intersects another range\n * @param {Range} rangeA\n * @param {Range} rangeB\n * @return {Range | null}\n */\nfunction getIntersectionRange (rangeA, rangeB) {\n  if (intersectsRange(rangeA, rangeB)) {\n    const range = rangeA.cloneRange();\n    if (range.compareBoundaryPoints(rangeB.START_TO_START, rangeB) === -1) {\n      range.setStart(rangeB.startContainer, rangeB.startOffset);\n    }\n\n    if (range.compareBoundaryPoints(rangeB.END_TO_END, rangeB) === 1) {\n      range.setEnd(rangeB.endContainer, rangeB.endOffset);\n    }\n\n    return range;\n  }\n\n  return null;\n}\n\n/**\n *\n * @param {Range} rangeA\n * @param {Range} rangeB\n * @return {boolean}\n */\nfunction isEqualRange (rangeA, rangeB) {\n  if (intersectsRange(rangeA, rangeB)) {\n    return rangeA.compareBoundaryPoints(rangeB.START_TO_START, rangeB) === 0 && rangeA.compareBoundaryPoints(rangeB.END_TO_END, rangeB) === 0;\n  }\n\n  return false;\n}\n\n/**\n *\n * @param {Range} rangeA\n * @param {Range} rangeB\n * @return {boolean}\n */\nfunction isAdjoinRange (rangeA, rangeB) {\n  return rangeA.compareBoundaryPoints(rangeB.END_TO_START, rangeB) === 0 || rangeA.compareBoundaryPoints(rangeB.START_TO_END, rangeB) === 0;\n}\n\n/**\n *\n * @param {Range} rangeA\n * @param {Range} rangeB\n * @return {Range | null}\n */\nfunction unionRange (rangeA, rangeB) {\n  const range = document.createRange();\n  if (intersectsRange(rangeA, rangeB) || isAdjoinRange(rangeA, rangeB)) {\n    range.setStart(rangeA.startContainer, rangeA.startOffset);\n    range.setEnd(rangeA.endContainer, rangeA.endOffset);\n    const start = rangeA.compareBoundaryPoints(rangeB.START_TO_START, rangeB);\n    const end = rangeA.compareBoundaryPoints(rangeB.END_TO_END, rangeB);\n\n    if (start === 1) {\n      range.setStart(rangeB.startContainer, rangeB.startOffset);\n    }\n\n    if (end === -1) {\n      range.setEnd(rangeB.endContainer, rangeB.endOffset);\n    }\n\n    return range;\n  }\n\n  return null\n}\n\nRange.prototype.inspect = function () {\n  // todo\n  const sel = window.getSelection();\n  sel.removeAllRanges();\n  sel.addRange(this);\n}\n\nextend(core, {\n  splitRangeBoundaries,\n  setRange,\n  RangeIterator,\n  insertNode,\n  getNodes,\n  intersectsRange,\n  getIntersectionRange,\n  getEffectiveTextNodes,\n  isEqualRange,\n  isAdjoinRange,\n  unionRange\n});\n\nexport default core;\n","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","'use strict'\n\nimport { rnothtmlwhite, stripAndCollapse } from '@/utils';\n\nconst classListSupport = !(typeof document.createElement('span').classList !== 'undefined');\nconst classNameSupport = !(typeof document.createElement('span').className !== 'undefined');\n\n/**\n *\n * @param {string|Array} value\n * @return {string[]}\n */\nexport function classesToArray (value) {\n  if (Array.isArray(value)) {\n    return value;\n  }\n  if (typeof value === 'string') {\n    return value.match(rnothtmlwhite) || [];\n  }\n  return [];\n}\n\n/**\n *\n * @param {HTMLElement} el\n * @param {string} value\n */\nexport function toggleClass (el, value) {\n  const classNames = classesToArray(value);\n\n  if (classNames.length && el.nodeType === Node.ELEMENT_NODE) {\n    classNames.forEach(className => {\n      if (classListSupport) {\n        el.classList.toggle(className);\n      } else {\n        if (hasClass(el, className)) {\n          removeClass(el, className);\n        } else {\n          addClass(el, className);\n        }\n      }\n    });\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n *\n * @param {HTMLElement} el\n * @return {string}\n */\nexport function getClass (el) {\n\n  if (el.nodeType !== Node.ELEMENT_NODE) {\n    return '';\n  }\n\n  if (classNameSupport) {\n    return el.className;\n  }\n\n  return el.getAttribute('class') || '';\n}\n\n/**\n *\n * @param {HTMLElement | Node} el\n * @param {string} value\n * @return {boolean}\n */\nexport function hasClass (el, value) {\n\n  if (el.nodeType !== Node.ELEMENT_NODE) {\n    return false;\n  }\n\n  if (classListSupport) {\n    return el.classList.contains(value);\n  }\n  const classNames = classesToArray(getClass(el));\n  return classNames.indexOf(value) > -1;\n}\n\n/**\n *\n * @param {HTMLElement | Node} el\n * @param {string} value\n */\nexport function addClass (el, value) {\n\n  let classNames = classesToArray(value), curClass, cur, final;\n\n  if (classNames.length && el.nodeType === Node.ELEMENT_NODE) {\n    if (classListSupport) {\n      el.classList.add(...classNames);\n    } else {\n      curClass = getClass(el);\n      cur = ' ' + stripAndCollapse(curClass) + ' ';\n      classNames.forEach(className => {\n        if (cur.indexOf(' ' + className + ' ') < 0) {\n          cur += className + ' '\n        }\n      });\n\n      final = stripAndCollapse(cur);\n\n      if (curClass !== final) {\n        if (classNameSupport) {\n          el.className = final;\n        } else {\n          el.setAttribute('class', final);\n        }\n      }\n    }\n  }\n}\n\n/**\n *\n * @param {HTMLElement | Node} el\n * @param {string} [value]\n */\nexport function removeClass (el, value) {\n\n  let classNames = classesToArray(value), curClass, cur, final,\n    isElement = (el.nodeType === Node.ELEMENT_NODE);\n\n  if (arguments.length < 2 && isElement) {\n    return el.removeAttribute('class');\n  }\n\n  if (classNames.length && isElement) {\n    if (classListSupport) {\n      el.classList.remove(...classNames);\n    } else {\n      curClass = getClass(el);\n      cur = ' ' + stripAndCollapse(curClass) + ' ';\n      classNames.forEach(className => {\n        while (cur.indexOf(' ' + className + ' ') > -1) {\n          cur = cur.replace(' ' + className + ' ', ' ');\n        }\n      });\n\n      final = stripAndCollapse(cur);\n      if (curClass !== final) {\n        if (classNameSupport) {\n          el.className = final;\n        } else {\n          el.setAttribute('class', final);\n        }\n      }\n    }\n  }\n}\n","'use strict'\n\nimport { extend, stripAndCollapse } from '@/utils';\nimport { addClass, toggleClass, getClass, removeClass, hasClass, classesToArray } from './classes';\nconst dom = {};\n\n/**\n *\n * @param {Node} node\n * @return {*}\n */\nexport function removeNode (node) {\n  return node.parentNode.removeChild(node);\n}\n\n/**\n *\n * @param {Node | null} node\n * @return {boolean}\n */\nexport function isCharacterDataNode (node) {\n  if (!node) return false;\n  const t = node.nodeType;\n  return t === Node.TEXT_NODE || t === Node.COMMENT_NODE;\n}\n\n/**\n * the position of the node in the parent node\n * @param {Node} node\n * @return {number}\n */\nexport function getNodeIndex (node) {\n  let index = 0;\n  while ((node = node.previousSibling)) {\n    index++;\n  }\n\n  return index;\n}\n\n/**\n * The element node returns the child node length, and the text node returns the text length\n * @param {Node|Text} node\n */\nexport function getNodeLength (node) {\n  const t = node.nodeType;\n  if (t === Node.ELEMENT_NODE) {\n    return node.childNodes.length;\n  } else if (isCharacterDataNode(node)) {\n    return node.length;\n  }\n  return 0;\n}\n\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} node\n * @return {Node | null}\n */\nexport function findClosestAncestor (ancestor, node) {\n  let p;\n  while (node) {\n    p = node.parentNode;\n    if (p === ancestor) {\n      return node\n    }\n    node = p;\n  }\n\n  return null;\n}\n\n/**\n *\n * @param {Node} node\n * @param {string} className\n * @return {Node | null}\n */\nexport function findSelfOrAncestorWithClass (node, className) {\n  while (node) {\n    if (hasClass(node, className)) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n  return null;\n}\n\n/**\n *\n * @param {string} selector\n * @return {HTMLElement | null}\n */\nexport function gE (selector) {\n  return document.querySelector(selector);\n}\n\n/**\n *\n * @param {Node} newNode\n * @param {Node} referenceNode\n * @return {Node}\n */\nexport function insertAfter (newNode, referenceNode) {\n  let p = referenceNode.parentNode, next = referenceNode.nextSibling;\n  if (!next) {\n    return p.appendChild(newNode);\n  } else {\n    return p.insertBefore(newNode, next);\n  }\n}\n\n/**\n *\n * @param {Node} newNode\n * @param {Node | Text} referenceNode\n * @param {number} offset\n * @return {Node}\n */\nexport function insertPoint (newNode, referenceNode, offset) {\n  if (isCharacterDataNode(referenceNode)) {\n    if (offset === referenceNode.length) {\n      insertAfter(newNode, referenceNode);\n    } else {\n      referenceNode.parentNode.insertBefore(newNode, offset === 0 ? referenceNode : referenceNode.splitText(offset));\n    }\n  } else if (offset >= referenceNode.childNodes.length) {\n    referenceNode.appendChild(newNode);\n  } else {\n    referenceNode.insertBefore(newNode, referenceNode.childNodes[offset]);\n  }\n\n  return newNode;\n}\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} descendant\n * @param {boolean} selfIsAncestor\n */\nexport function isAncestorOf (ancestor, descendant, selfIsAncestor) {\n  let n = selfIsAncestor ? descendant : descendant.parentNode;\n  while (n) {\n    if (n === ancestor) {\n      return true;\n    } else {\n      n = n.parentNode;\n    }\n  }\n  return false;\n}\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} descendant\n * @return {boolean}\n */\nexport function isOrIsAncestorOf(ancestor, descendant) {\n  return isAncestorOf(ancestor, descendant, true);\n}\n\n/**\n *\n * @param {RangeIterator} it\n * @param {(node: Node) => void} cb\n */\nexport function iterateSubtree (it, cb) {\n  let node;\n  while((node = it.next())) {\n    if (it.isPartiallySelectedSubtree()) {\n      const subIt = it.getSubtreeIterator();\n      iterateSubtree(subIt, cb);\n    } else {\n      const nit = new NodeIterator(node);\n      while((node = nit.next())) {\n        cb(node);\n      }\n    }\n  }\n}\n\n/**\n *\n * @param {Node} textNode\n * @return {boolean}\n */\nexport function isWhiteSpaceTextNode (textNode) {\n  return textNode && textNode.nodeType === Text.TEXT_NODE && stripAndCollapse(textNode.data) === '';\n}\n\n/**\n *\n * @param {Element} el\n * @param {string} propName\n */\nexport function getComputedStyleProperty(el, propName) {\n  return window.getComputedStyle(el, null).getPropertyValue(propName);\n}\n\nfunction NodeIterator(root) {\n  this.root = root;\n  this._next = root;\n}\n\nNodeIterator.prototype = {\n  _current: null,\n\n  hasNext: function() {\n    return !!this._next;\n  },\n\n  next: function() {\n    let n = this._current = this._next;\n    let child, next;\n    if (this._current) {\n      child = n.firstChild;\n      if (child) {\n        this._next = child;\n      } else {\n        next = null;\n        while ((n !== this.root) && !(next = n.nextSibling)) {\n          n = n.parentNode;\n        }\n        this._next = next;\n      }\n    }\n    return this._current;\n  },\n\n  detach: function() {\n    this._current = this._next = this.root = null;\n  }\n};\n\n/**\n *\n * @param {Selection} selection\n * @return {Range[]}\n */\nexport function getAllRange (selection) {\n  const ranges = [];\n  for (let i = 0; i < selection.rangeCount; ++i) {\n    ranges.push(selection.getRangeAt(i));\n  }\n\n  return ranges;\n}\n\nexport { addClass, toggleClass, getClass, removeClass, hasClass, classesToArray }\n\nextend(dom, {\n  removeNode,\n  getNodeLength,\n  getNodeIndex,\n  gE,\n  isCharacterDataNode,\n  findClosestAncestor,\n  insertAfter,\n  addClass,\n  toggleClass,\n  getClass,\n  removeClass,\n  hasClass,\n  classesToArray,\n  insertPoint,\n  isAncestorOf,\n  isOrIsAncestorOf,\n  iterateSubtree,\n  findSelfOrAncestorWithClass,\n  getComputedStyleProperty,\n  getAllRange\n});\n\nexport default dom;\n","'use strict'\n\nimport core from '@/core';\nimport { getAllRange } from '@/dom';\n\nclass CharacterRange {\n\n  constructor(start, end, referenceNode) {\n    this.start = start;\n    this.end = end;\n    this.referenceNode = referenceNode;\n    this.isCollapsed = this.start === this.end;\n  }\n\n  isEqual (otherCharacterRange) {\n    otherCharacterRange = balanceRange(otherCharacterRange, this.referenceNode);\n    return this.start === otherCharacterRange.start && this.end === otherCharacterRange.end;\n  }\n\n  isIntersects (otherCharacterRange) {\n    otherCharacterRange = balanceRange(otherCharacterRange, this.referenceNode);\n    return this.start < otherCharacterRange.end && this.end > otherCharacterRange.start;\n  }\n\n  isAdjoin (otherCharacterRange) {\n    otherCharacterRange = balanceRange(otherCharacterRange, this.referenceNode);\n    return this.start === otherCharacterRange.end || this.end === otherCharacterRange.start\n  }\n\n  union (otherCharacterRange) {\n    otherCharacterRange = balanceRange(otherCharacterRange, this.referenceNode);\n    if (this.isIntersects(otherCharacterRange) || this.isAdjoin(otherCharacterRange)) {\n      return new CharacterRange(Math.min(this.start, otherCharacterRange.start), Math.max(this.end, otherCharacterRange.end), this.referenceNode);\n    }\n    return null\n  }\n\n  intersection (otherCharacterRange) {\n    otherCharacterRange = balanceRange(otherCharacterRange, this.referenceNode);\n    if (this.isIntersects(otherCharacterRange)) {\n      return new CharacterRange(Math.max(this.start, otherCharacterRange.start), Math.min(this.end, otherCharacterRange.end), this.referenceNode);\n    }\n\n    return null;\n  }\n\n  complementarySet (otherCharacterRange) {\n    const characterRanges = [];\n    otherCharacterRange = balanceRange(otherCharacterRange, this.referenceNode);\n\n    if (this.start < otherCharacterRange.start) {\n      characterRanges.push(new CharacterRange(this.start, otherCharacterRange.start, this.referenceNode));\n    }\n\n    if (this.end > otherCharacterRange.end) {\n      characterRanges.push(new CharacterRange(otherCharacterRange.end, this.end, this.referenceNode));\n    }\n\n    return characterRanges;\n  }\n\n  toRange () {\n    const range = document.createRange();\n    const { start, end } = this;\n    range.setStart(this.referenceNode, 0);\n    range.collapse(true);\n\n    const nodeIterator = document.createNodeIterator(this.referenceNode, NodeFilter.SHOW_TEXT);\n    let textNode, charIndex = 0, nextCharIndex;\n\n    let foundStart = false, foundEnd = false;\n    while (!foundEnd && (textNode = nodeIterator.nextNode())) {\n      nextCharIndex = charIndex + textNode.length;\n      if (!foundStart && start >= charIndex && start <= nextCharIndex) {\n        range.setStart(textNode, start - charIndex);\n        foundStart = true;\n      }\n\n      if (end >= charIndex && end <= nextCharIndex) {\n        range.setEnd(textNode, end - charIndex);\n        foundEnd = true;\n      }\n      charIndex = nextCharIndex;\n    }\n\n    return range;\n  }\n\n  /**\n   *\n   * @param {Range} range\n   * @param {Node} [referenceNode]\n   * @return {CharacterRange}\n   */\n  static fromRange (range, referenceNode) {\n    const surroundRange = range.cloneRange();\n    surroundRange.selectNodeContents(referenceNode);\n    const intersectionRange = core.getIntersectionRange(range, surroundRange);\n\n    let start = 0, end = 0;\n    if (intersectionRange) {\n      surroundRange.setEnd(intersectionRange.startContainer, intersectionRange.startOffset);\n      start = surroundRange.toString().length;\n      end = start + intersectionRange.toString().length\n    }\n\n    return new CharacterRange(start, end, referenceNode);\n  }\n\n  /**\n   *\n   * @param {Selection} selection\n   * @param {Node} [referenceNode]\n   * @return {CharacterRange[]}\n   */\n  static fromSelection (selection, referenceNode) {\n    const characterRanges = []\n    getAllRange(selection).forEach(range => {\n      characterRanges.push(CharacterRange.fromRange(range, referenceNode));\n    });\n\n    return characterRanges;\n  }\n}\n\n/**\n *\n * @param characterRange\n * @param referenceNode\n * @return {CharacterRange}\n */\nfunction balanceRange (characterRange, referenceNode) {\n  const range = characterRange.toRange();\n  return CharacterRange.fromRange(range, referenceNode);\n}\n\nexport default CharacterRange;","'use strict'\n\nimport toType from './toType';\nimport Trie from './trie';\n\nconst utils = {};\n\nexport function extend () {\n  let options, name, src, copy, copyIsArray, clone,\n    target = arguments[0] || {},\n    i = 1,\n    length = arguments.length,\n    deep = false;\n\n  if (typeof target === 'boolean') {\n    deep = target;\n\n    target = arguments[i] || {};\n    i++;\n  }\n\n  if (typeof target !== 'object' && typeof target !== 'function') {\n    target = {};\n  }\n\n  if (i === length) {\n    target = this;\n    i--;\n  }\n\n  for (; i < length; i++) {\n\n    if ((options = arguments[i] ) != null) {\n\n      for (name in options) {\n        copy = options[ name ];\n\n        if (name === '__proto__' || target === copy) {\n          continue;\n        }\n\n        if (deep && copy && (isPlainObject(copy) ||\n          (copyIsArray = Array.isArray(copy)))) {\n          src = target[name];\n\n          if (copyIsArray && !Array.isArray(src)) {\n            clone = [];\n          } else if (!copyIsArray && !isPlainObject(src)) {\n            clone = {};\n          } else {\n            clone = src;\n          }\n          copyIsArray = false;\n\n          target[name] = extend(deep, clone, copy);\n\n        } else if (copy !== undefined) {\n          target[name] = copy;\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nexport function isPlainObject (obj) {\n  let proto, Ctor;\n\n  if (!obj || toString.call(obj) !== '[object Object]') {\n    return false;\n  }\n\n  proto = Object.getPrototypeOf(obj);\n\n  if (!proto) {\n    return true;\n  }\n\n  Ctor = {}.hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor === 'function' && {}.hasOwnProperty.toString.call(Ctor) === {}.hasOwnProperty.toString.call(Object);\n}\n\nexport const rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\nexport function stripAndCollapse( value ) {\n  const tokens = value.match(rnothtmlwhite) || [];\n  return tokens.join(' ');\n}\n\nexport function each (obj, callback) {\n  for (let i in obj) {\n    if (callback.call(obj[i], i, obj[i]) === false) {\n      break;\n    }\n  }\n\n  return obj;\n}\n\nexport {\n  toType,\n  Trie\n}\n\nextend(utils, {\n  extend,\n  isPlainObject,\n  stripAndCollapse,\n  rnothtmlwhite,\n  toType,\n  each,\n  Trie\n});\n\nexport default utils;\n","'use strict'\n\nconst class2type = {};\nconst toString = class2type.toString;\n\n['Object', 'Array', 'Function', 'Date', 'RegExp'].forEach(function (type) {\n  class2type[`[object ${type}]`] = type.toLowerCase();\n});\n\nfunction toType(obj) {\n  if (obj == null) {\n    return obj + '';\n  }\n\n  return typeof obj === 'object' ?\n    class2type[toString.call(obj)] || 'object' :\n    typeof obj;\n}\n\nexport default toType;","/**\n * js implementation of Trie\n *\n * The root node contains no characters, and every node except the root node contains only one character.\n *\n * From the root node to a node, the characters passing through the path are concatenated, which is the corresponding string of the node;\n *\n * All children of each node contain different characters.\n */\n'use strict'\n\nclass TrieNode {\n  /**\n   *\n   * @param {string} char\n   */\n  constructor(char) {\n    this.char = char;\n    this.isEnd = false;\n    this.children = {};\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new TrieNode('');\n  }\n\n  /**\n   *\n   * @param {string} word\n   */\n  addWord (word) {\n    let current = this.root, next;\n\n    for (const char of word) {\n      next = current.children[char];\n      if (!next) {\n        current.children[char] = next = new TrieNode(char);\n      }\n      current = next;\n    }\n\n    current.isEnd = true;\n  }\n\n  /**\n   *\n   * @param {string} word\n   * @return {boolean}\n   */\n  search (word) {\n    let current = this.root;\n\n    for (const char of word) {\n      if (!current.children[char]) {\n        return false\n      }\n      current = current.children[char];\n    }\n\n    return current.isEnd;\n  }\n\n  /**\n   *\n   * @param {string} word\n   * @return {boolean}\n   */\n  startsWith (word) {\n    let current = this.root;\n\n    for (const char of word) {\n      if (!current.children[char]) {\n        return false\n      }\n\n      current = current.children[char];\n    }\n\n    return containsWords(current);\n  }\n\n  /**\n   *\n   * @param {string} word\n   */\n  removeWord (word) {\n    let current = this.root;\n    const hierarchy = [current];\n    const words = [];\n\n    for (let piece of word) {\n      words.unshift(piece);\n      if (!current.children[piece]) {\n        return;\n      }\n\n      current = current.children[piece];\n      hierarchy.unshift(current);\n    }\n\n    current.isEnd = false;\n\n    for (let j = 0; j < hierarchy.length; j++) {\n      if (Object.keys(hierarchy[j].children).length > 0 || hierarchy[j].isEnd) {\n        break;\n      }\n\n      if (j + 1 < hierarchy.length) {\n        delete hierarchy[j + 1].children[words[j]];\n      }\n    }\n  }\n\n}\n\n/**\n *\n * @param {TrieNode} node\n * @return {boolean}\n */\nfunction containsWords (node) {\n  if (node.isEnd) {\n    return true;\n  }\n\n  for (const key in node.children) {\n    if (Object.hasOwn(node.children, key)) {\n      if (containsWords(node.children[key])) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport default Trie;\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","'use strict'\n\nimport core from '@/core';\nimport {\n  addClass,\n  findSelfOrAncestorWithClass,\n  removeNode,\n  isCharacterDataNode,\n  getNodeIndex,\n  removeClass\n} from '@/dom';\nimport { each } from '@/utils';\n\nfunction createOptions (options) {\n  const defaultOptions = {\n    tagName: 'span',\n    className: 'highlight',\n    elAttrs: {},\n    elProps: {}\n  }\n\n  each(options, (propName, propValue) => {\n    defaultOptions[propName] = propValue;\n  });\n\n  return defaultOptions;\n}\n\n/**\n * Applier Object\n */\n\nexport default class Refills {\n  constructor(options) {\n    this.options = createOptions(options);\n  }\n\n  /**\n   *\n   * @param {Range} range\n   */\n  appliesToRange (range) {\n    core.splitRangeBoundaries(range);\n\n    const textNodes = core.getEffectiveTextNodes(range);\n\n    if (textNodes.length) {\n      textNodes.forEach(textNode => {\n        if (!findSelfOrAncestorWithClass(textNode, this.options.className)) {\n          this.appliesToTextNode(textNode);\n        }\n      });\n\n      const lastTextNode = textNodes[textNodes.length - 1];\n      core.setRange(range, textNodes[0], 0, lastTextNode, lastTextNode.length);\n\n      this.normalize(textNodes, range, false);\n    }\n  }\n\n  /**\n   *\n   * @param {Range} range\n   */\n  wipeToRange (range) {\n    core.splitRangeBoundaries(range);\n\n    const textNodes = core.getEffectiveTextNodes(range);\n\n    if (textNodes.length) {\n      // split boundaries ancestor with class\n      splitBoundariesAncestorWithClass(range, this.options.className);\n      textNodes.forEach(textNode => {\n        let ancestorWithClass = findSelfOrAncestorWithClass(textNode, this.options.className);\n        if (ancestorWithClass) {\n          this.wipeToAncestor(ancestorWithClass);\n        }\n      });\n\n      const lastTextNode = textNodes[textNodes.length - 1];\n      core.setRange(range, textNodes[0], 0, lastTextNode, lastTextNode.length);\n\n      this.normalize(textNodes, range, true);\n    }\n  }\n\n  wipeToAncestor (ancestorWithClass) {\n    if (this.isEqualNode(ancestorWithClass)) {\n      let child, index = getNodeIndex(ancestorWithClass);\n      const parentNode = ancestorWithClass.parentNode;\n\n      while ((child = ancestorWithClass.firstChild)) {\n        // move children to sibling\n        moveNode(child, parentNode, index++);\n      }\n\n      removeNode(ancestorWithClass);\n    } else {\n      removeClass(ancestorWithClass, this.options.className);\n    }\n  }\n\n  /**\n   *\n   * @param {Node} textNode\n   */\n  appliesToTextNode (textNode) {\n    const parentNode = textNode.parentNode;\n    if (textNode.nodeType === Node.TEXT_NODE) {\n      const el = this.createElement();\n      parentNode.insertBefore(el, textNode);\n      el.appendChild(textNode);\n    }\n  }\n\n  /**\n   *\n   * @param {Range} range\n   */\n  isAppliedToRange (range) {\n    let textNode, textNodes = core.getEffectiveTextNodes(range);\n    if (textNodes.length) {\n      for (let i = 0; (textNode = textNodes[i++]);) {\n        if (!findSelfOrAncestorWithClass(textNode, this.options.className)) {\n          return false;\n        }\n      }\n\n      return true;\n    } else {\n      return !!findSelfOrAncestorWithClass(range.commonAncestorContainer, this.options.className);\n    }\n  }\n\n  /**\n   *\n   * @return {HTMLElement | Node}\n   */\n  createElement () {\n    const el = document.createElement(this.options.tagName);\n    addClass(el, this.options.className);\n    mapAttrs(el, this.options.elAttrs);\n    mapProps(el, this.options.elProps);\n    return el;\n  }\n\n  normalize (textNodes, range, isUndo) {\n    let firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];\n\n    let currentMerge = null, merges = [];\n\n    let rangeStartNode = firstNode, rangeEndNode = lastNode;\n    let rangeStartOffset = 0, rangeEndOffset = lastNode.length;\n\n    textNodes.forEach(textNode => {\n      // go through each textNode and find the mergable node in front of them,\n      const precedingNode = getPrecedingMrTextNode(textNode, !isUndo, this.isEqualNode.bind(this));\n\n      if (precedingNode) {\n        // create a Merge object headed by precedingNode\n        if (currentMerge == null) {\n          currentMerge = new Merge(precedingNode);\n          merges.push(currentMerge);\n        }\n        currentMerge.textNodes.push(textNode);\n\n        if (rangeStartNode === textNode) {\n          rangeStartNode = currentMerge.textNodes[0];\n          rangeStartOffset = rangeStartNode.length;\n        }\n\n        if (rangeEndNode === textNode) {\n          rangeEndNode = currentMerge.textNodes[0];\n          rangeEndOffset = currentMerge.getLength();\n        }\n\n      } else {\n        // reset the current Merge object to create a new merge\n        currentMerge = null;\n      }\n    });\n\n    const nextNode = getNextMrTextNode(lastNode, !isUndo, this.isEqualNode.bind(this));\n\n    if (nextNode) {\n      if (currentMerge == null) {\n        currentMerge = new Merge(lastNode);\n        merges.push(currentMerge);\n      }\n      currentMerge.textNodes.push(nextNode);\n    }\n\n    if (merges.length) {\n      merges.forEach(merge => merge.start());\n\n      core.setRange(range, rangeStartNode, rangeStartOffset, rangeEndNode, rangeEndOffset);\n    }\n\n  }\n\n  isEqualNode (node) {\n    return this.createElement().cloneNode(false).isEqualNode(node.cloneNode(false));\n  }\n}\n\nconst getPrecedingMrTextNode = getter(false);\n\nconst getNextMrTextNode = getter(true);\n\nfunction getter (forward) {\n  const adjacentPropName = forward ? 'nextSibling' : 'previousSibling';\n  const position = forward ? 'firstChild' : 'lastChild';\n  return function (textNode, checkParentElement, filter) {\n\n    let adjacentNode = textNode[adjacentPropName], parentNode = textNode.parentNode;\n\n    if (adjacentNode && adjacentNode.nodeType === Node.TEXT_NODE) {\n      return adjacentNode\n    } else if (checkParentElement) {\n      adjacentNode = parentNode[adjacentPropName];\n      if (adjacentNode && adjacentNode.nodeType === Node.ELEMENT_NODE) {\n        if (filter && !filter(adjacentNode)) {\n          return null;\n        }\n        let adjacentNodeChild = adjacentNode[position];\n        if (adjacentNodeChild && adjacentNodeChild.nodeType === Node.TEXT_NODE) {\n          return adjacentNodeChild\n        }\n      }\n    }\n\n    return null\n  }\n}\n\nclass Merge {\n  /**\n   *\n   * @param {Node | Text} node\n   */\n  constructor(node) {\n    this.firstTextNode = node.nodeType === Node.ELEMENT_NODE ? node.firstChild : node;\n    this.textNodes = [this.firstTextNode];\n  }\n\n  start () {\n    const textParts = [];\n    this.textNodes.forEach((textNode, index) => {\n      const parentNode = textNode.parentNode;\n      if (index > 0) {\n        removeNode(textNode);\n        if (!parentNode.hasChildNodes()) {\n          removeNode(parentNode);\n        }\n      }\n      textParts.push(textNode.data);\n    });\n\n    this.firstTextNode.data = textParts.join('');\n    return this.firstTextNode.data;\n  }\n\n  getLength () {\n    let len = 0;\n    this.textNodes.forEach(textNode => {\n      len += textNode.length;\n    });\n    return len;\n  }\n}\n\nfunction mapAttrs (el, attrs) {\n  each(attrs, function (attrName, attrValue) {\n    if (Object.hasOwn(attrs, attrName) && !/^class(?:Name)?$/i.test(attrName)) {\n      el.setAttribute(attrName, attrValue);\n    }\n  });\n}\n\nfunction mapProps (el, props) {\n  each(props, function (propName, propValue) {\n    if (Object.hasOwn(props, propName)) {\n      if (propName === 'className') {\n        addClass(el, propValue);\n      } else {\n        el[propName] = propValue;\n      }\n    }\n  });\n}\n\nfunction splitBoundariesAncestorWithClass (range, className) {\n  [{ node: range.endContainer, offset: range.endOffset }, { node: range.startContainer, offset: range.startOffset }]\n    .forEach(({ node, offset }) => {\n      const ancestorWithClass = findSelfOrAncestorWithClass(node, className);\n      if (ancestorWithClass) {\n        splitNodeAt(ancestorWithClass, node, offset);\n      }\n    });\n}\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node | Text} descendant\n * @param {number} descendantOffset\n */\nexport function splitNodeAt (ancestor, descendant, descendantOffset) {\n\n  let newNode, splitAtStart = (descendantOffset === 0);\n\n  if (isCharacterDataNode(descendant)) {\n    let index = getNodeIndex(descendant);\n\n    if (descendantOffset === 0) {\n      descendantOffset = index;\n    } else if (descendantOffset === descendant.data.length) {\n      descendantOffset = index + 1;\n    }\n    descendant = descendant.parentNode;\n  }\n\n  if (isSplitPoint(descendant, descendantOffset)) {\n    // clone empty node\n    newNode = descendant.cloneNode(false);\n    if (newNode.hasAttribute('id')) {\n      newNode.removeAttribute('id');\n    }\n    let child, newIndex = 0;\n    while ((child = descendant.childNodes[descendantOffset])) {\n      // move child to newNode\n      moveNode(child, newNode, newIndex++);\n    }\n    // move newNode to parentNode\n    moveNode(newNode, descendant.parentNode, getNodeIndex(descendant) + 1);\n  } else if (ancestor !== descendant) {\n    newNode = descendant.parentNode;\n\n    // Work out a new split point in the parent node\n    let newNodeIndex = getNodeIndex(descendant);\n\n    if (!splitAtStart) {\n      newNodeIndex++;\n    }\n    return splitNodeAt(ancestor, newNode, newNodeIndex);\n  }\n}\n\nfunction moveNode (node, newNode, newIndex) {\n  if (newIndex === -1) {\n    newIndex = newNode.childNodes.length;\n  }\n\n  if (newIndex === newNode.childNodes.length) {\n    newNode.appendChild(node);\n  } else {\n    newNode.insertBefore(node, newNode.childNodes[newIndex]);\n  }\n}\n\nfunction isSplitPoint(node, offset) {\n  // Node.TEXT_NODE\n  if (isCharacterDataNode(node)) {\n    if (offset === 0) {\n      return !!node.previousSibling;\n    } else if (offset === node.length) {\n      return !!node.nextSibling;\n    } else {\n      return true;\n    }\n  }\n\n  // Node.ELEMENT_NODE\n  return offset > 0 && offset < node.childNodes.length;\n}","'use strict'\n\nimport core from '@/core';\n\nclass Highlight {\n  constructor(characterRange, refills) {\n    this.characterRange = characterRange;\n    this.refills = refills;\n    this.applied = false;\n  }\n\n  on() {\n    this.range = this.characterRange.toRange();\n    this.refills.appliesToRange(this.range);\n    this.applied = true;\n  }\n\n  off () {\n    this.range = this.characterRange.toRange();\n    this.refills.wipeToRange(this.range);\n    this.applied = false;\n  }\n\n  intersectsNode(node) {\n    const range = document.createRange();\n    range.selectNodeContents(node);\n\n    return core.intersectsRange(this.characterRange.toRange(), range);\n  }\n\n  _inspect () {\n    inspect(this);\n  }\n\n}\n\nfunction inspect (highlight) {\n  const characterRange = highlight.characterRange;\n  const range = characterRange.toRange(), characterText = range.toString();\n\n  console.log('{');\n  console.log('  commonAncestor:', range.commonAncestorContainer);\n  console.log(`  characterText: %c${characterText}`, consoleStyle);\n  console.log(`  characterRange: { start: ${characterRange.start}, end: ${characterRange.end} }`);\n  console.log(`  applied:`, highlight.applied);\n  console.log('}');\n}\n\nconst consoleStyle = [\n  'background: rgb(254, 232, 195)',\n  'color: rgb(51, 51, 51)',\n  'border: 1px solid #ccc',\n  'border-radius: 4px',\n  'padding: 2px'\n].join(';');\n\nexport default Highlight;","'use strict'\n\nconst apply = Function.prototype.apply, call = Function.prototype.call;\n\nclass EventEmitter {\n  constructor() {\n    this.__events__ = {};\n  }\n\n  on (type, listener) {\n    const data = this.__events__;\n    if (!data[type]) data[type] = listener;\n    else if (typeof data[type] === 'object') data[type].push(listener);\n    else data[type] = [data[type], listener];\n\n    return this;\n  }\n\n  once (type, listener) {\n    let once, self;\n\n    self = this;\n    self.on.call(this, type, once = function () {\n      self.off.call(self, type, once);\n      apply.call(listener, self, arguments);\n    });\n\n    once.__eeOnceListener__ = listener;\n    return this;\n  }\n\n  off (type, listener) {\n    const data = this.__events__;\n    if (!data[type]) return this;\n\n    const listeners = data[type];\n\n    if (typeof listeners === 'object') {\n      for (let i = 0, candidate; (candidate = listeners[i]); ++i) {\n        if ((candidate === listener) ||\n          (candidate.__eeOnceListener__ === listener)) {\n          if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n          else listeners.splice(i, 1);\n        }\n      }\n    } else {\n      if ((listeners === listener) ||\n        (listeners.__eeOnceListener__ === listener)) {\n        delete data[type];\n      }\n    }\n\n    return this;\n  }\n\n  emit (type) {\n    let listeners = this.__events__[type];\n    if (!listeners) return;\n\n    let l, args, i;\n\n    if (typeof listeners === 'object') {\n      l = arguments.length;\n      args = new Array(l - 1);\n      for (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n      listeners = listeners.slice();\n      for (let i = 0, listener; (listener = listeners[i]); ++i) {\n        apply.call(listener, this, args);\n      }\n    } else {\n      switch (arguments.length) {\n        case 1:\n          call.call(listeners, this);\n          break;\n        case 2:\n          call.call(listeners, this, arguments[1]);\n          break;\n        case 3:\n          call.call(listeners, this, arguments[1], arguments[2]);\n          break;\n        default:\n          l = arguments.length;\n          args = new Array(l - 1);\n          for (i = 1; i < l; ++i) {\n            args[i - 1] = arguments[i];\n          }\n          apply.call(listeners, this, args);\n      }\n    }\n  }\n}\n\nexport default EventEmitter;","'use strict'\n\nimport Refills from '@/refills';\nimport CharacterRange from './characterRange';\nimport Highlight from './highlight';\nimport EventEmitter from './eventEmitter';\nimport { each } from '@/utils';\n\nclass Highlighter extends EventEmitter {\n  constructor(options) {\n    super();\n    this.setOptions(options);\n    this.highlights = [];\n  }\n\n  /**\n   *\n   * @param [options]\n   * @return {Highlight[]}\n   */\n  highlightASelection (options) {\n    options = createOptions(options);\n\n    const selection = getSelection(options.selection),\n      referenceNode = getReferenceNode(options.referenceNodeId);\n\n    const characterRanges = CharacterRange.fromSelection(selection, referenceNode);\n\n    const highlights = this._highlightCharacterRanges(characterRanges);\n\n    restoreSelection(selection, characterRanges);\n\n    return highlights;\n  }\n\n  unHighlightASelection (options) {\n    options = createOptions(options);\n\n    const selection = getSelection(options.selection),\n      referenceNode = getReferenceNode(options.referenceNodeId);\n\n    const characterRanges = CharacterRange.fromSelection(selection, referenceNode);\n\n    this._unHighlightCharacterRanges(characterRanges);\n\n    restoreSelection(selection, characterRanges);\n  }\n\n  isHighlightedASelection () {\n  }\n\n  /**\n   *\n   * @param {CharacterRange[]} characterRanges\n   * @return {Highlight[]}\n   */\n  _highlightCharacterRanges (characterRanges) {\n\n    const undoToHighligts = [];\n\n    for (let i = 0, characterRange; (characterRange = characterRanges[i++]);) {\n      if (characterRange.isCollapsed) {\n        // ignore empty characterRange\n        continue;\n      }\n\n      let isEqual = false;\n      for (let j = 0, stockHighlight; (stockHighlight = this.highlights[j]); ++j) {\n        // if (characterRange.referenceNode !== stockHighlight.characterRange.referenceNode) {\n        //   continue;\n        // }\n\n        if (characterRange.isEqual(stockHighlight.characterRange)) {\n          isEqual = true;\n          continue;\n        }\n\n        if (characterRange.isIntersects(stockHighlight.characterRange) || characterRange.isAdjoin(stockHighlight.characterRange)) {\n          characterRange = characterRange.union(stockHighlight.characterRange);\n          undoToHighligts.push(stockHighlight);\n          this.highlights.splice(j--, 1);\n        }\n      }\n\n      if (!isEqual) {\n        this.highlights.push(new Highlight(characterRange, this.refills));\n      }\n    }\n\n    undoToHighligts.forEach(highlight => {\n      if (highlight.applied) {\n        highlight.off();\n      }\n    });\n\n    const newHighlight = [];\n    this.highlights.forEach(ht => {\n      if (!ht.applied) {\n        ht.on();\n        newHighlight.push(ht)\n      }\n    });\n\n    return newHighlight\n  }\n\n  _unHighlightCharacterRanges (characterRanges) {\n\n    const undoToHighlights = [];\n\n    for (let i = 0, characterRange; (characterRange = characterRanges[i++]); ) {\n      if (characterRange.isCollapsed) {\n        continue;\n      }\n\n      for (let j = 0, stockHighlight; (stockHighlight = this.highlights[j]); ++j) {\n        if (characterRange.isIntersects(stockHighlight.characterRange)) {\n          const intersectionCr = characterRange.intersection(stockHighlight.characterRange);\n          const complementCrs = stockHighlight.characterRange.complementarySet(intersectionCr);\n          complementCrs.forEach(complementCr => {\n            // add complement\n            this.highlights.push(new Highlight(complementCr, this.refills));\n          });\n          undoToHighlights.push(stockHighlight);\n          this.highlights.splice(j--, 1);\n        }\n      }\n    }\n\n    undoToHighlights.forEach(highlight => {\n      if (highlight.applied) {\n        highlight.off();\n      }\n    });\n\n    this.highlights.forEach(ht => {\n      if (!ht.applied) {\n        ht.on();\n      }\n    });\n  }\n\n  /**\n   *\n   * @param {HTMLElement} el\n   * @return {Highlight | null}\n   */\n  getHighlightForElement (el) {\n    for (let i = 0, highlight; (highlight = this.highlights[i++]);) {\n      if (highlight.intersectsNode(el)) {\n        return highlight;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   *\n   * @param {Highlight} highlight\n   */\n  removeHighlight (highlight) {\n    if (highlight instanceof Highlight) {\n      let highlights = this.highlights, index;\n      if ((index = highlights.indexOf(highlight)) > -1) {\n        if (highlight.applied) {\n          highlight.off();\n        }\n\n        highlights.splice(index, 1);\n      }\n    }\n  }\n\n  removeAllHighlight () {\n    for (let i = 0, highlight; (highlight = this.highlights[i]); ++i) {\n      if (highlight.applied) {\n        highlight.off();\n      }\n      this.highlights.splice(i--, 1);\n    }\n  }\n\n  _handleHighlightClick (event, el) {\n    this.emit('click', this.getHighlightForElement(el), el, event);\n  }\n\n  setOptions (options) {\n    const newOptions = {};\n\n    const self = this;\n    function handleHighlightClick (event) {\n      self._handleHighlightClick(event, this);\n    }\n\n    each(options, (propName, propValue) => {\n      newOptions[propName] = propValue;\n    });\n\n    newOptions['elProps'] = {\n      ...newOptions['elProps'],\n      onclick: handleHighlightClick\n    }\n\n    this.refills = new Refills(newOptions);\n\n    return newOptions;\n  }\n\n  save () {\n    // todo\n    // https://github.com/LukasRada/rangee\n    // https://github.com/tildeio/range-serializer\n  }\n\n  restore () {\n\n  }\n}\n\nfunction createOptions(options) {\n  const newOptions = {};\n\n  each(options, (propName, propValue) => {\n    newOptions[propName] = propValue;\n  });\n\n  return newOptions;\n}\n\nfunction getReferenceNode (id) {\n  const el = document.getElementById(id);\n  if (el) {\n    return el;\n  }\n\n  return document.body;\n}\n\nfunction getSelection (selection) {\n  if (selection instanceof Selection) {\n    return selection;\n  }\n\n  return window.getSelection();\n}\n\n/**\n *\n * @param {Selection} selection\n * @param {CharacterRange[]} characterRanges\n */\nfunction restoreSelection (selection, characterRanges) {\n  selection.removeAllRanges();\n  characterRanges.forEach(characterRange => {\n    if (!characterRange.isCollapsed) {\n      selection.addRange(characterRange.toRange());\n    }\n  });\n}\n\nexport default Highlighter;\n","'use strict'\n\nimport core from '@/core';\nimport dom from '@/dom';\nimport utils from '@/utils';\nimport Refills from '@/refills';\nimport Highlighter from '@/highlighter';\n\nexport {\n  dom,\n  utils,\n  Refills,\n  Highlighter\n}\n\nexport default core;\n"],"names":["root","factory","exports","module","define","amd","this","core","setRange","range","ec","eo","sc","arguments","so","len","getNodeLength","length","setStart","setEnd","RangeIterator","clonePartiallySelectedTextNodes","collapsed","commonAncestorContainer","startContainer","startOffset","endContainer","endOffset","isCharacterDataNode","_next","_end","findClosestAncestor","childNodes","current","_current","nextSibling","cloneNode","deleteData","isOrIsAncestorOf","document","createRange","getNodes","nodeTypes","filter","regx","nodes","RegExp","join","iterateSubtree","node","test","nodeType","push","rangeSelectsAnyText","textNode","textNodeRange","selectNodeContents","intersectionRange","getIntersectionRange","toString","intersectsRange","rangeA","rangeB","start","compareBoundaryPoints","END_TO_START","end","START_TO_END","cloneRange","START_TO_START","END_TO_END","isAdjoinRange","Range","prototype","inspect","sel","window","getSelection","removeAllRanges","addRange","extend","splitRangeBoundaries","startSameEnd","splitText","parentNode","getNodeIndex","insertNode","firstNode","n","i","Node","DOCUMENT_FRAGMENT_NODE","insertPoint","setStartBefore","getEffectiveTextNodes","textNodes","TEXT_NODE","slice","isEqualRange","unionRange","_toConsumableArray","arr","Array","isArray","arrayLikeToArray","iter","Symbol","iterator","from","unsupportedIterableToArray","TypeError","classListSupport","createElement","classList","classNameSupport","className","classesToArray","value","match","rnothtmlwhite","getClass","el","ELEMENT_NODE","getAttribute","hasClass","contains","indexOf","addClass","curClass","cur","final","classNames","add","stripAndCollapse","forEach","setAttribute","removeClass","isElement","removeAttribute","remove","replace","removeNode","removeChild","t","COMMENT_NODE","index","previousSibling","ancestor","p","findSelfOrAncestorWithClass","insertAfter","newNode","referenceNode","next","insertBefore","appendChild","offset","isAncestorOf","descendant","selfIsAncestor","it","cb","isPartiallySelectedSubtree","getSubtreeIterator","nit","NodeIterator","getAllRange","selection","ranges","rangeCount","getRangeAt","hasNext","child","firstChild","detach","gE","selector","querySelector","toggleClass","toggle","getComputedStyleProperty","propName","getComputedStyle","getPropertyValue","CharacterRange","isCollapsed","otherCharacterRange","balanceRange","isIntersects","isAdjoin","Math","min","max","characterRanges","collapse","nextCharIndex","nodeIterator","createNodeIterator","NodeFilter","SHOW_TEXT","charIndex","foundStart","foundEnd","nextNode","surroundRange","fromRange","characterRange","toRange","options","name","src","copy","copyIsArray","clone","target","deep","isPlainObject","undefined","obj","proto","Ctor","call","Object","getPrototypeOf","hasOwnProperty","constructor","each","callback","toType","Trie","class2type","type","toLowerCase","TrieNode","char","isEnd","children","containsWords","key","hasOwn","word","hierarchy","words","piece","unshift","j","keys","_arrayLikeToArray","arr2","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","enumerable","configurable","writable","defineProperty","_createClass","protoProps","staticProps","_defineProperty","_typeof","_unsupportedIterableToArray","o","minLen","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","get","prop","getter","forward","adjacentPropName","position","checkParentElement","adjacentNode","adjacentNodeChild","Function","apply"],"sourceRoot":""}