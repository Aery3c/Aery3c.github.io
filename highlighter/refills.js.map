{"version":3,"file":"refills.js","mappings":"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","sources":["webpack://highlighter/webpack/bootstrap","webpack://highlighter/webpack/runtime/define property getters","webpack://highlighter/webpack/runtime/hasOwnProperty shorthand","webpack://highlighter/webpack/runtime/make namespace object","webpack://highlighter/./src/dom-utils/isCharacterDataNode.js","webpack://highlighter/./src/dom-utils/getNodeIndex.js","webpack://highlighter/./src/dom-utils/crudNode.js","webpack://highlighter/./src/dom-utils/classes.js","webpack://highlighter/./src/dom-utils/findClosestAncestor.js","webpack://highlighter/./src/dom-utils/getNodeLength.js","webpack://highlighter/./src/dom-utils/index.js","webpack://highlighter/./src/range-utils/setRange.js","webpack://highlighter/./src/range-utils/intersection.js","webpack://highlighter/./src/range-utils/rangeIterator.js","webpack://highlighter/./src/range-utils/getNodes.js","webpack://highlighter/./src/range-utils/selection.js","webpack://highlighter/./src/range-utils/index.js","webpack://highlighter/./src/range-utils/splitRangeBoundaries.js","webpack://highlighter/./src/utils/each.js","webpack://highlighter/./src/refills.js","webpack://highlighter/./src/utils/createOptions.js","webpack://highlighter/./src/utils/eventEmitter.js","webpack://highlighter/./examples/refills/refills.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// @flow\n'use strict'\n\nexport function isCharacterDataNode (node: Node | null): boolean {\n  if (!node) return false;\n  const t = node.nodeType;\n  return t === Node.TEXT_NODE || t === Node.COMMENT_NODE;\n}","// @flow\n'use strict'\n\nexport function getNodeIndex (node: Node): number {\n  let index = 0;\n  // $FlowIgnore\n  while ((node = node.previousSibling)) {\n    index++;\n  }\n\n  return index;\n}","// @flow\n'use strict'\nimport { isCharacterDataNode } from './isCharacterDataNode';\nimport { getNodeIndex } from './getNodeIndex';\n\nexport function splitNode (ancestor: any, descendant: any, descendantOffset: any): void {\n\n  let newNode, splitAtStart = (descendantOffset === 0);\n\n  if (isCharacterDataNode(descendant)) {\n    let index = getNodeIndex(descendant);\n\n    if (descendantOffset === 0) {\n      descendantOffset = index;\n\n    } else if (descendantOffset === descendant.data.length) {\n      descendantOffset = index + 1;\n    }\n    descendant = descendant.parentNode;\n  }\n\n  if (isSplitPoint(descendant, descendantOffset)) {\n    // clone empty node\n    newNode = descendant.cloneNode(false);\n    if (newNode.hasAttribute('id')) {\n      newNode.removeAttribute('id');\n    }\n    let child, newIndex = 0;\n    while ((child = descendant.childNodes[descendantOffset])) {\n      // move child to newNode\n      moveNode(child, newNode, newIndex++);\n    }\n    // move newNode to parentNode\n    moveNode(newNode, descendant.parentNode, getNodeIndex(descendant) + 1);\n  } else if (ancestor !== descendant) {\n    newNode = descendant.parentNode;\n\n    // Work out a new split point in the parent node\n    let newNodeIndex = getNodeIndex(descendant);\n\n    if (!splitAtStart) {\n      newNodeIndex++;\n    }\n    return splitNode(ancestor, newNode, newNodeIndex);\n  }\n}\n\nfunction isSplitPoint(node: Node, offset: number): boolean {\n  // Node.TEXT_NODE\n  if (isCharacterDataNode(node)) {\n    if (offset === 0) {\n      return !!node.previousSibling;\n      // $FlowIgnore\n    } else if (offset === node.length) {\n      return !!node.nextSibling;\n    } else {\n      return true;\n    }\n  }\n\n  // Node.ELEMENT_NODE\n  return offset > 0 && offset < node.childNodes.length;\n}\nexport function removeNode (node: Node): Node | null {\n  const p = node.parentNode;\n  if (p) {\n    return p.removeChild(node);\n  }\n\n  return null;\n}\n\nexport function moveNode (node: Node, newNode: Node, newIndex: number): void {\n  if (newIndex === -1) {\n    newIndex = newNode.childNodes.length;\n  }\n\n  if (newIndex === newNode.childNodes.length) {\n    newNode.appendChild(node);\n  } else {\n    newNode.insertBefore(node, newNode.childNodes[newIndex]);\n  }\n}","// @flow\n'use strict'\n\nconst classListSupport = !(typeof document.createElement('span').classList !== 'undefined');\nconst classNameSupport = !(typeof document.createElement('span').className !== 'undefined');\n\n// $FlowIgnore\nexport const rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\nexport function stripAndCollapse (value: string): string {\n  const tokens = value.match(rnothtmlwhite) || [];\n  return tokens.join(' ');\n}\n\n/**\n *\n * @param {string|Array} value\n * @return {string[]}\n */\nexport function classesToArray (value: string | Array<string>): string[] {\n  if (Array.isArray(value)) {\n    return value;\n  }\n  if (typeof value === 'string') {\n    return value.match(rnothtmlwhite) || [];\n  }\n  return [];\n}\n\n/**\n *\n * @param {HTMLElement} el\n * @param {string} value\n */\nexport function toggleClass (el: HTMLElement, value: string): boolean {\n  const classNames = classesToArray(value);\n\n  if (classNames.length && el.nodeType === Node.ELEMENT_NODE) {\n    classNames.forEach(className => {\n      if (classListSupport) {\n        el.classList.toggle(className);\n      } else {\n        if (hasClass(el, className)) {\n          removeClass(el, className);\n        } else {\n          addClass(el, className);\n        }\n      }\n    });\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n *\n * @param {HTMLElement} el\n * @return {string}\n */\nexport function getClass (el: HTMLElement): string {\n\n  if (el.nodeType !== Node.ELEMENT_NODE) {\n    return '';\n  }\n\n  if (classNameSupport) {\n    return el.className;\n  }\n\n  return el.getAttribute('class') || '';\n}\n\n/**\n *\n */\nexport function hasClass (el: HTMLElement, value: string): boolean {\n\n  if (el.nodeType !== Node.ELEMENT_NODE) {\n    return false;\n  }\n\n  if (classListSupport) {\n    return el.classList.contains(value);\n  }\n  const classNames = classesToArray(getClass(el));\n  return classNames.indexOf(value) > -1;\n}\n\n/**\n *\n * @param {HTMLElement | Node} el\n * @param {string} value\n */\nexport function addClass (el: HTMLElement, value: string): void {\n\n  let classNames = classesToArray(value), curClass, cur, final;\n\n  if (classNames.length && el.nodeType === Node.ELEMENT_NODE) {\n    if (classListSupport) {\n      el.classList.add(...classNames);\n    } else {\n      curClass = getClass(el);\n      cur = ' ' + stripAndCollapse(curClass) + ' ';\n      classNames.forEach(className => {\n        if (cur.indexOf(' ' + className + ' ') < 0) {\n          cur += className + ' '\n        }\n      });\n\n      final = stripAndCollapse(cur);\n\n      if (curClass !== final) {\n        if (classNameSupport) {\n          el.className = final;\n        } else {\n          el.setAttribute('class', final);\n        }\n      }\n    }\n  }\n}\n\n/**\n *\n * @param {HTMLElement | Node} el\n * @param {string} [value]\n */\nexport function removeClass (el: HTMLElement, value: string): void {\n\n  let classNames = classesToArray(value), curClass, cur, final,\n    isElement = (el.nodeType === Node.ELEMENT_NODE);\n\n  if (arguments.length < 2 && isElement) {\n    return el.removeAttribute('class');\n  }\n\n  if (classNames.length && isElement) {\n    if (classListSupport) {\n      el.classList.remove(...classNames);\n    } else {\n      curClass = getClass(el);\n      cur = ' ' + stripAndCollapse(curClass) + ' ';\n      classNames.forEach(className => {\n        while (cur.indexOf(' ' + className + ' ') > -1) {\n          cur = cur.replace(' ' + className + ' ', ' ');\n        }\n      });\n\n      final = stripAndCollapse(cur);\n      if (curClass !== final) {\n        if (classNameSupport) {\n          el.className = final;\n        } else {\n          el.setAttribute('class', final);\n        }\n      }\n    }\n  }\n}\n","// @flow\n'use strict'\n\nimport { hasClass } from './classes';\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} node\n * @return {Node | null}\n */\nexport function findClosestAncestor (ancestor: Node, node: Node): Node | null {\n  let p;\n  while (node) {\n    p = node.parentNode;\n    if (p === ancestor) {\n      return node\n    }\n    // $FlowIgnore\n    node = p;\n  }\n\n  return null;\n}\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} descendant\n * @param {boolean} selfIsAncestor\n */\nexport function isAncestorOf (ancestor: Node, descendant: Node, selfIsAncestor: boolean): boolean {\n  let n = selfIsAncestor ? descendant : descendant.parentNode;\n  while (n) {\n    if (n === ancestor) {\n      return true;\n    } else {\n      n = n.parentNode;\n    }\n  }\n  return false;\n}\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} descendant\n * @return {boolean}\n */\nexport function isOrIsAncestorOf(ancestor: Node, descendant: Node): boolean {\n  return isAncestorOf(ancestor, descendant, true);\n}\n\nexport function findSelfOrAncestorWithClass (node: Node, className: string): Node | null {\n  while (node) {\n    // $FlowIgnore\n    if (hasClass(node, className)) {\n      return node;\n    }\n    // $FlowIgnore\n    node = node.parentNode;\n  }\n  return null;\n}\n\n","// @flow\n'use strict'\n\n/**\n * The element node returns the child node length, and the text node returns the text length\n * @param {Node|Text} node\n */\n\nimport { isCharacterDataNode } from './isCharacterDataNode';\n\nexport function getNodeLength (node: Node): number {\n  const t = node.nodeType;\n  if (t === Node.ELEMENT_NODE) {\n    return node.childNodes.length;\n  } else if (isCharacterDataNode(node)) {\n    // $FlowIgnore\n    return node.length;\n  }\n  return 0;\n}","// @flow\n\nimport * as crudNode from './crudNode';\nimport * as classes from './classes';\nimport * as findClosestAncestor from './findClosestAncestor';\nimport { isCharacterDataNode } from './isCharacterDataNode';\nimport { getNodeIndex } from './getNodeIndex';\nimport { getNodeLength } from './getNodeLength';\n\nexport default {\n  ...crudNode,\n  ...classes,\n  ...findClosestAncestor,\n  isCharacterDataNode,\n  getNodeIndex,\n  getNodeLength,\n  getSelection\n};","// @flow\n'use strict'\nimport { getNodeLength } from '../dom-utils/getNodeLength';\n\nexport function setRange (range: Range, ...args: Array<any>) {\n  let sc = args[0], so = args[1], ec, eo;\n  const len = getNodeLength(sc);\n\n  switch (args.length) {\n    case 2:\n      ec = sc;\n      eo = len;\n      break;\n    case 3:\n      ec = args[2];\n      eo = so;\n      break;\n    case 4:\n      ec = args[2];\n      eo = args[3];\n      break;\n  }\n\n  range.setStart(sc, so);\n  // $FlowIgnore\n  range.setEnd(ec, eo);\n}\n","// @flow\n'use strict'\n\n/**\n * Returns the part of a specified range that intersects another range\n */\nexport function getIntersectionRange (rangeA: Range, rangeB: Range): Range | null {\n  if (intersectsRange(rangeA, rangeB)) {\n    const range = rangeA.cloneRange();\n    // $FlowIgnore\n    if (range.compareBoundaryPoints(rangeB.START_TO_START, rangeB) === -1) {\n      range.setStart(rangeB.startContainer, rangeB.startOffset);\n    }\n    // $FlowIgnore\n    if (range.compareBoundaryPoints(rangeB.END_TO_END, rangeB) === 1) {\n      range.setEnd(rangeB.endContainer, rangeB.endOffset);\n    }\n\n    return range;\n  }\n\n  return null;\n}\n\n/**\n * Returns a boolean indicating whether the given Range intersects the Range.\n */\nexport function intersectsRange (rangeA: Range, rangeB: Range): boolean {\n  // rangeA.s < rangeB.e;\n  // $FlowIgnore\n  const start = rangeA.compareBoundaryPoints(rangeB.END_TO_START, rangeB);\n  // rangeA.e > rangeB.s;\n  // $FlowIgnore\n  const end = rangeA.compareBoundaryPoints(rangeB.START_TO_END, rangeB);\n\n  return start < 0 && end > 0;\n}","// @flow\n'use strict'\n\nimport { isCharacterDataNode } from '../dom-utils/isCharacterDataNode';\nimport { findClosestAncestor, isOrIsAncestorOf } from '../dom-utils/findClosestAncestor';\nimport { getNodeLength } from '../dom-utils/getNodeLength';\nimport { setRange } from './setRange';\n\nexport class RangeIterator {\n  range: Range;\n  clonePartiallySelectedTextNodes: boolean;\n  root: Node;\n  sc: Node;\n  so: number;\n  ec: Node;\n  eo: number;\n  _current: Node | null = null;\n  _end: Node | null = null;\n  _next: Node | null = null;\n  constructor(range: Range, clonePartiallySelectedTextNodes?: boolean = false) {\n    this.range = range;\n    this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n    if (!this.range.collapsed) {\n      this.root = this.range.commonAncestorContainer;\n      this.sc = this.range.startContainer;\n      this.so = this.range.startOffset;\n      this.ec = this.range.endContainer;\n      this.eo = this.range.endOffset;\n\n      if (this.sc === this.ec && isCharacterDataNode(this.sc)) {\n        this._next = this._end = this.sc;\n      } else {\n        this._next = this.sc === this.root && !isCharacterDataNode(this.sc)\n          ? this.sc.childNodes[this.so] : findClosestAncestor(this.root, this.sc)\n\n        this._end = this.ec === this.root && !isCharacterDataNode(this.ec)\n          ? this.ec.childNodes[this.eo - 1] : findClosestAncestor(this.root, this.ec);\n      }\n    }\n\n  }\n  next (): Node | null {\n    let current = this._current = this._next;\n    // $FlowIgnore\n    this._next = this._current != null && this._current !== this._end ? this._current.nextSibling : null;\n\n    // Check for partially selected text nodes\n    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n      // clone partially selected text nodes\n      // return cloneNode\n      if (current === this.ec) {\n        // $FlowIgnore\n        (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n      }\n\n      if (current === this.sc) {\n        // $FlowIgnore\n        (current = current.cloneNode(true)).deleteData(0, this.so);\n      }\n    }\n\n    return current;\n  }\n\n  isPartiallySelectedSubtree (): boolean {\n    return !isCharacterDataNode(this._current) &&\n      // $FlowIgnore\n      (isOrIsAncestorOf(this._current, this.sc) || isOrIsAncestorOf(this._current, this.ec));\n  }\n\n  getSubtreeIterator (): RangeIterator {\n    const range = document.createRange(), current = this._current;\n    // $FlowIgnore\n    let startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);\n\n    if (current) {\n      if (isOrIsAncestorOf(current, this.sc)) {\n        startContainer = this.sc;\n        startOffset = this.so;\n      }\n      if (isOrIsAncestorOf(current, this.ec)) {\n        endContainer = this.ec;\n        endOffset = this.eo;\n      }\n    }\n\n    setRange(range, startContainer, startOffset, endContainer, endOffset);\n\n    return new RangeIterator(range, this.clonePartiallySelectedTextNodes);\n  }\n}\n\nexport function iterateSubtree (it: RangeIterator, cb: (node: Node) => void) {\n  let node;\n  while((node = it.next())) {\n    if (it.isPartiallySelectedSubtree()) {\n      const subIt = it.getSubtreeIterator();\n      iterateSubtree(subIt, cb);\n    } else {\n      const nit = document.createNodeIterator(node);\n      while((node = nit.nextNode())) {\n        cb(node);\n      }\n    }\n  }\n}","// @flow\n'use strict'\n\nimport { RangeIterator, iterateSubtree } from './rangeIterator';\nimport { getIntersectionRange } from './intersection';\n\nexport function getNodes (range: Range, nodeTypes?: Array<number>, filter?: (node: Node) => boolean): Node[] {\n  let nodes = [], regx;\n  if (nodeTypes && nodeTypes.length) {\n    regx = new RegExp(`(${nodeTypes.join('|')})$`);\n  }\n\n  iterateSubtree(new RangeIterator(range, false), (node) => {\n    if (regx && !regx.test(node.nodeType.toString())) {\n      return;\n    }\n\n    if (typeof filter == 'function' && !filter(node)) {\n      return;\n    }\n\n    nodes.push(node);\n  });\n\n  return nodes;\n}\n\n/**\n * range (prev/next) point (last/first)\n * @param range\n */\nexport function getEffectiveTextNodes (range: Range): Node[] {\n  const textNodes = getNodes(range, [Node.TEXT_NODE]);\n\n  let start = 0, end = textNodes.length, node;\n\n  // remove invalid text nodes from left to right\n  while ((node = textNodes[start]) && !rangeSelectsAnyText(range, node)) {\n    ++start;\n  }\n\n  // remove invalid text nodes from right to left\n  while ((node = textNodes[end - 1]) && !rangeSelectsAnyText(range, node)) {\n    --end;\n  }\n\n  return textNodes.slice(start, end);\n}\n\n\nfunction rangeSelectsAnyText(range: Range, textNode: Node): boolean {\n  const textNodeRange = document.createRange();\n  textNodeRange.selectNodeContents(textNode);\n  const intersectionRange = getIntersectionRange(textNodeRange, range);\n  const text = intersectionRange ? intersectionRange.toString() : '';\n  return text !== '';\n}\n","// @flow\n'use strict'\n\nexport function getSelection (sel?: any): Selection {\n  if (sel instanceof Selection) {\n    return sel;\n  }\n\n  return window.getSelection();\n}\n\nexport function getRangesInSelection (selection: Selection): Range[] {\n  const ranges = [];\n  for (let i = 0; i < selection.rangeCount; ++i) {\n    ranges.push(selection.getRangeAt(i));\n  }\n\n  return ranges;\n}","// @flow\n'use strict'\nimport { setRange } from './setRange';\nimport * as intersection from './intersection';\nimport * as getNodes from './getNodes';\nimport * as rangeIterator from './rangeIterator';\nimport { splitRangeBoundaries } from './splitRangeBoundaries';\nimport * as selection from './selection';\n\nexport default {\n  ...intersection,\n  ...getNodes,\n  ...rangeIterator,\n  ...selection,\n  splitRangeBoundaries,\n  setRange\n}","// @flow\n'use strict'\n\nimport { isCharacterDataNode } from '../dom-utils/isCharacterDataNode';\nimport { getNodeIndex } from '../dom-utils/getNodeIndex';\n\nexport function splitRangeBoundaries (range: Range): void {\n  let [sc, so, ec, eo] = [range.startContainer, range.startOffset, range.endContainer, range.endOffset];\n  const startSameEnd: boolean = (sc === ec);\n  // $FlowIgnore\n  if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n    // $FlowIgnore\n    ec.splitText(eo);\n  }\n  // $FlowIgnore\n  if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n    // $FlowIgnore\n    sc = sc.splitText(so);\n    if (startSameEnd) {\n      eo -= so;\n      ec = sc;\n    } else if (ec === sc.parentNode && eo <= getNodeIndex(sc)) {\n      eo++;\n    }\n    so = 0;\n  }\n}","// @flow\n'use strict'\n\nimport type { Obj } from '../types';\nexport function each (obj: Obj, callback: (propName: any, propValue: any) => boolean | void): Obj {\n  for (let i in obj) {\n    if (callback.call(obj[i], i, obj[i]) === false) {\n      break;\n    }\n  }\n\n  return obj;\n}","// @flow\n'use strict'\n\nimport type { RefillsOptions, DefaultRefillsOptions } from './types';\nimport domUtils from './dom-utils';\nimport rangeUtils from './range-utils';\nimport { createRefillsOptions } from './utils/createOptions';\nimport { each } from './utils/each';\n\nexport default class Refills {\n  options: DefaultRefillsOptions;\n  constructor(options?: RefillsOptions) {\n    this.options = createRefillsOptions(options);\n  }\n\n  appliesToRange (range: Range): void {\n    rangeUtils.splitRangeBoundaries(range);\n\n    const textNodes = rangeUtils.getEffectiveTextNodes(range);\n    if (textNodes.length) {\n      textNodes.forEach(textNode => {\n        if (this.options.className && !domUtils.findSelfOrAncestorWithClass(textNode, this.options.className)) {\n          this.appliesToTextNode(textNode);\n        }\n      });\n\n      const lastTextNode = textNodes[textNodes.length - 1];\n      // $FlowIgnore\n      rangeUtils.setRange(range, textNodes[0], 0, lastTextNode, lastTextNode.length);\n      if (this.options.normalize) {\n        this.normalize(textNodes, range, false);\n      }\n    }\n  }\n\n  appliesToTextNode (textNode: Node): void {\n    const parentNode = textNode.parentNode;\n    if (textNode.nodeType === Node.TEXT_NODE && parentNode) {\n      const el = this.createElement();\n      if (el) {\n        parentNode.insertBefore(el, textNode);\n        el.appendChild(textNode);\n      }\n    }\n  }\n\n  wipeToRange (range: Range): void {\n    rangeUtils.splitRangeBoundaries(range);\n\n    const textNodes = rangeUtils.getEffectiveTextNodes(range);\n\n    if (textNodes.length) {\n      // split boundaries ancestor with class\n      splitBoundariesAncestorWithClass(range, this.options.className);\n      textNodes.forEach(textNode => {\n        let ancestorWithClass = domUtils.findSelfOrAncestorWithClass(textNode, this.options.className);\n        if (ancestorWithClass) {\n          this.wipeToAncestor(ancestorWithClass);\n        }\n      });\n\n      const lastTextNode = textNodes[textNodes.length - 1];\n      // $FlowIgnore\n      rangeUtils.setRange(range, textNodes[0], 0, lastTextNode, lastTextNode.length);\n      if (this.options.normalize) {\n        this.normalize(textNodes, range, true);\n      }\n    }\n  }\n\n  wipeToAncestor (ancestor: any): void {\n    if (this.isEqualNode(ancestor)) {\n      let child, index = domUtils.getNodeIndex(ancestor);\n      const parentNode = ancestor.parentNode;\n\n      while ((child = ancestor.firstChild)) {\n        // move children to sibling\n        domUtils.moveNode(child, parentNode, index++);\n      }\n\n      domUtils.removeNode(ancestor);\n    } else {\n      domUtils.removeClass(ancestor, this.options.className);\n    }\n  }\n\n  createElement (): HTMLElement | null {\n    if (this.options.tagName) {\n      const el = document.createElement(this.options.tagName);\n      if (this.options.className && this.options.elAttrs && this.options.elProps) {\n        domUtils.addClass(el, this.options.className);\n        // $FlowIgnore\n        mapAttrs(el, this.options.elAttrs);\n        // $FlowIgnore\n        mapProps(el, this.options.elProps);\n      }\n      return el;\n    }\n\n    return null;\n  }\n\n  normalize (textNodes: Node[], range: Range, isUndo: boolean): void {\n    let firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];\n\n    let currentMerge = null, merges = [];\n\n    let rangeStartNode = firstNode, rangeEndNode = lastNode;\n    // $FlowIgnore\n    let rangeStartOffset = 0, rangeEndOffset = lastNode.length;\n\n    textNodes.forEach(textNode => {\n      // go through each textNode and find the mergable node in front of them,\n      const precedingNode = getPrecedingMrTextNode(textNode, !isUndo, (node) => {\n        return this.isEqualNode(node);\n      });\n\n      if (precedingNode) {\n        // create a Merge object headed by precedingNode\n        if (currentMerge == null) {\n          currentMerge = new Merge(precedingNode);\n          merges.push(currentMerge);\n        }\n        // $FlowIgnore\n        currentMerge.textNodes.push(textNode);\n\n        if (rangeStartNode === textNode) {\n          // $FlowIgnore\n          rangeStartNode = currentMerge.textNodes[0];\n          // $FlowIgnore\n          rangeStartOffset = rangeStartNode.length;\n        }\n\n        if (rangeEndNode === textNode) {\n          // $FlowIgnore\n          rangeEndNode = currentMerge.textNodes[0];\n          // $FlowIgnore\n          rangeEndOffset = currentMerge.getLength();\n        }\n\n      } else {\n        // reset the current Merge object to create a new merge\n        currentMerge = null;\n      }\n    });\n\n    const nextNode = getNextMrTextNode(lastNode, !isUndo, (node) => {\n      return this.isEqualNode(node);\n    });\n\n    if (nextNode) {\n      if (currentMerge == null) {\n        currentMerge = new Merge(lastNode);\n        merges.push(currentMerge);\n      }\n      // $FlowIgnore\n      currentMerge.textNodes.push(nextNode);\n    }\n\n    if (merges.length) {\n      merges.forEach(merge => merge.start());\n\n      rangeUtils.setRange(range, rangeStartNode, rangeStartOffset, rangeEndNode, rangeEndOffset);\n    }\n  }\n\n  isEqualNode (node: Node): boolean {\n    const newNode = this.createElement();\n    if (newNode) {\n      return newNode.cloneNode(false).isEqualNode(node.cloneNode(false));\n    }\n    return false;\n  }\n}\n\nfunction mapAttrs (el: HTMLElement, attrs: Object) {\n  each(attrs, function (attrName, attrValue) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (attrs.hasOwnProperty(attrName) && !/^class(?:Name)?$/i.test(attrName)) {\n      el.setAttribute(attrName, attrValue);\n    }\n  });\n}\n\nfunction mapProps (el: HTMLElement, props: Object) {\n  each(props, function (propName, propValue) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (props.hasOwnProperty(propName)) {\n      if (propName === 'className') {\n        domUtils.addClass(el, propValue);\n      } else {\n        // $FlowIgnore\n        el[propName] = propValue;\n      }\n    }\n  });\n}\n\nconst getPrecedingMrTextNode = getter(false);\n\nconst getNextMrTextNode = getter(true);\nfunction getter (forward: boolean): ((textNode: Node, checkParentElement: boolean, filter?: (node: Node) => boolean) => Node | null) {\n  const adjacentPropName = forward ? 'nextSibling' : 'previousSibling';\n  const position = forward ? 'firstChild' : 'lastChild';\n  return function (textNode, checkParentElement, filter) {\n    // $FlowIgnore\n    let adjacentNode = textNode[adjacentPropName], parentNode = textNode.parentNode;\n\n    if (adjacentNode && adjacentNode.nodeType === Node.TEXT_NODE) {\n      return adjacentNode\n    } else if (checkParentElement) {\n      // $FlowIgnore\n      adjacentNode = parentNode[adjacentPropName];\n      if (adjacentNode && adjacentNode.nodeType === Node.ELEMENT_NODE) {\n        if (filter && !filter(adjacentNode)) {\n          return null;\n        }\n        let adjacentNodeChild = adjacentNode[position];\n        if (adjacentNodeChild && adjacentNodeChild.nodeType === Node.TEXT_NODE) {\n          return adjacentNodeChild\n        }\n      }\n    }\n\n    return null\n  }\n}\n\nfunction splitBoundariesAncestorWithClass (range: Range, className: string): void {\n  [{ node: range.endContainer, offset: range.endOffset }, { node: range.startContainer, offset: range.startOffset }]\n    .forEach(({ node, offset }) => {\n      const ancestorWithClass = domUtils.findSelfOrAncestorWithClass(node, className);\n      if (ancestorWithClass) {\n        domUtils.splitNode(ancestorWithClass, node, offset);\n      }\n    });\n}\n\nclass Merge {\n  firstTextNode: Node;\n  textNodes: Node[];\n  constructor(node: Node) {\n    const n = node.nodeType === Node.ELEMENT_NODE ? node.firstChild : node;\n    if (n) {\n      this.firstTextNode = n;\n      this.textNodes = [n];\n    }\n  }\n\n  start (): string {\n    const textParts = [];\n    this.textNodes.forEach((textNode, index) => {\n      const parentNode = textNode.parentNode;\n      if (index > 0 && parentNode) {\n        domUtils.removeNode(textNode);\n        if (!parentNode.hasChildNodes()) {\n          domUtils.removeNode(parentNode);\n        }\n      }\n      // $FlowIgnore\n      textParts.push(textNode.data);\n    });\n    // $FlowIgnore\n    this.firstTextNode.data = textParts.join('');\n    return this.firstTextNode.data;\n  }\n\n  getLength (): number {\n    let len = 0;\n    this.textNodes.forEach(textNode => {\n      // $FlowIgnore\n      len += textNode.length;\n    });\n    return len;\n  }\n}","// @flow\n\n'use strict'\nimport type { RefillsOptions, DefaultRefillsOptions } from '../types';\n\nimport { each } from './each';\nexport function createRefillsOptions (options?: RefillsOptions = {}): DefaultRefillsOptions {\n  const defaultOptions = {\n    tagName: 'span',\n    className: 'highlight',\n    elAttrs: {},\n    elProps: {},\n    normalize: true\n  }\n\n  each(options, (propName, propValue) => {\n    // eslint-disable-next-line no-prototype-builtins\n    if (options.hasOwnProperty(propName)) {\n      defaultOptions[propName] = propValue;\n    }\n  });\n\n  return defaultOptions;\n}\n\n","// @flow\n/* global $Values */\n'use strict'\n\ntype Listener = (...args: Array<any>) => void;\ntype ListenerMap = { [key: string]: Listener };\nconst apply = Function.prototype.apply, call = Function.prototype.call;\nexport default class EventEmitter<U: ListenerMap> {\n  __events__: Object;\n  constructor() {\n    this.__events__ = {};\n  }\n\n  on<T: string> (type: T, listener: $Values<U>): EventEmitter<U> {\n    const data = this.__events__;\n    if (!data[type]) data[type] = listener;\n    else if (typeof data[type] === 'object') data[type].push(listener);\n    else data[type] = [data[type], listener];\n\n    return this;\n  }\n\n  once<T: string> (type: T, listener: $Values<U>): EventEmitter<U> {\n    let once, self;\n\n    self = this;\n    // $FlowIgnore\n    self.on.call(self, type, once = function () {\n      // $FlowIgnore\n      self.off.call(self, type, once);\n      apply.call(listener, self, arguments);\n    });\n    // $FlowIgnore\n    once.__onceListener__ = listener;\n    return this;\n  }\n\n  off<T: string> (type: T, listener: $Values<U>): EventEmitter<U> {\n    const data = this.__events__;\n    if (!data[type]) return this;\n\n    const listeners = data[type];\n\n    if (typeof listeners === 'object') {\n      for (let i = 0, candidate; (candidate = listeners[i]); ++i) {\n        if ((candidate === listener) ||\n          (candidate.__onceListener__ === listener)) {\n          if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n          else listeners.splice(i, 1);\n        }\n      }\n    } else {\n      if ((listeners === listener) ||\n        (listeners.__onceListener__ === listener)) {\n        delete data[type];\n      }\n    }\n\n    return this;\n  }\n\n  emit<T: string> (type: T, ...args: Array<any>): void {\n    let listeners = this.__events__[type];\n    if (!listeners) return;\n\n    let l, i;\n\n    if (typeof listeners === 'object') {\n      l = arguments.length;\n      args = new Array(l - 1);\n      for (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n      listeners = listeners.slice();\n      for (let i = 0, listener; (listener = listeners[i]); ++i) {\n        apply.call(listener, this, args);\n      }\n    } else {\n      switch (arguments.length) {\n        case 1:\n          call.call(listeners, this);\n          break;\n        case 2:\n          call.call(listeners, this, arguments[1]);\n          break;\n        case 3:\n          call.call(listeners, this, arguments[1], arguments[2]);\n          break;\n        default:\n          l = arguments.length;\n          args = new Array(l - 1);\n          for (i = 1; i < l; ++i) {\n            args[i - 1] = arguments[i];\n          }\n          apply.call(listeners, this, args);\n      }\n    }\n  }\n}","// @flow\nimport { Refills } from '../../src';\n\nconst refills = new Refills({ tagName: 'span' });\n\ndocument.getElementById('appliesToRange')?.addEventListener('click', () => {\n  refills.appliesToRange(window.getSelection().getRangeAt(0));\n});\n\ndocument.getElementById('wipeToRange')?.addEventListener('click', () => {\n  refills.wipeToRange(window.getSelection().getRangeAt(0));\n});"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","isCharacterDataNode","node","t","nodeType","Node","TEXT_NODE","COMMENT_NODE","getNodeIndex","index","previousSibling","splitNode","ancestor","descendant","descendantOffset","newNode","offset","splitAtStart","data","length","parentNode","nextSibling","childNodes","cloneNode","hasAttribute","removeAttribute","child","newIndex","moveNode","newNodeIndex","removeNode","p","removeChild","appendChild","insertBefore","classListSupport","document","createElement","classList","classNameSupport","className","rnothtmlwhite","stripAndCollapse","match","join","classesToArray","Array","isArray","toggleClass","el","classNames","ELEMENT_NODE","forEach","toggle","hasClass","removeClass","addClass","getClass","getAttribute","contains","indexOf","curClass","cur","final","add","setAttribute","isElement","arguments","remove","replace","findClosestAncestor","isAncestorOf","selfIsAncestor","n","isOrIsAncestorOf","findSelfOrAncestorWithClass","getNodeLength","crudNode","classes","getSelection","setRange","range","ec","eo","sc","so","len","setStart","setEnd","getIntersectionRange","rangeA","rangeB","intersectsRange","cloneRange","compareBoundaryPoints","START_TO_START","startContainer","startOffset","END_TO_END","endContainer","endOffset","start","END_TO_START","end","START_TO_END","RangeIterator","clonePartiallySelectedTextNodes","this","collapsed","root","commonAncestorContainer","_next","_end","current","_current","deleteData","createRange","iterateSubtree","it","cb","next","isPartiallySelectedSubtree","getSubtreeIterator","nit","createNodeIterator","nextNode","getNodes","nodeTypes","filter","regx","nodes","RegExp","test","toString","push","getEffectiveTextNodes","textNodes","rangeSelectsAnyText","slice","textNode","textNodeRange","selectNodeContents","intersectionRange","sel","Selection","window","getRangesInSelection","selection","ranges","i","rangeCount","getRangeAt","intersection","rangeIterator","splitRangeBoundaries","startSameEnd","splitText","each","callback","Refills","options","defaultOptions","tagName","elAttrs","elProps","normalize","propName","propValue","createRefillsOptions","rangeUtils","domUtils","appliesToTextNode","lastTextNode","ancestorWithClass","splitBoundariesAncestorWithClass","wipeToAncestor","isEqualNode","firstChild","attrs","attrName","attrValue","mapAttrs","props","mapProps","isUndo","firstNode","lastNode","currentMerge","merges","rangeStartNode","rangeEndNode","rangeStartOffset","rangeEndOffset","precedingNode","getPrecedingMrTextNode","Merge","getLength","getNextMrTextNode","merge","getter","forward","adjacentPropName","position","checkParentElement","adjacentNode","adjacentNodeChild","firstTextNode","textParts","hasChildNodes","Function","apply","refills","getElementById","addEventListener","appliesToRange","wipeToRange"],"sourceRoot":""}