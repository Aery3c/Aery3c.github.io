{"version":3,"file":"findText.js","mappings":"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","sources":["webpack://highlighter/webpack/bootstrap","webpack://highlighter/webpack/runtime/define property getters","webpack://highlighter/webpack/runtime/hasOwnProperty shorthand","webpack://highlighter/webpack/runtime/make namespace object","webpack://highlighter/./examples/findText/TextSearch.js","webpack://highlighter/./src/dom-utils/isCharacterDataNode.js","webpack://highlighter/./src/dom-utils/getNodeIndex.js","webpack://highlighter/./src/dom-utils/crudNode.js","webpack://highlighter/./src/dom-utils/classes.js","webpack://highlighter/./src/dom-utils/findClosestAncestor.js","webpack://highlighter/./src/dom-utils/getNodeLength.js","webpack://highlighter/./src/dom-utils/index.js","webpack://highlighter/./src/range-utils/setRange.js","webpack://highlighter/./src/range-utils/intersection.js","webpack://highlighter/./src/range-utils/rangeIterator.js","webpack://highlighter/./src/range-utils/getNodes.js","webpack://highlighter/./src/range-utils/selection.js","webpack://highlighter/./src/range-utils/index.js","webpack://highlighter/./src/range-utils/splitRangeBoundaries.js","webpack://highlighter/./src/utils/each.js","webpack://highlighter/./src/refills.js","webpack://highlighter/./src/utils/createOptions.js","webpack://highlighter/./src/utils/characterRange.js","webpack://highlighter/./src/utils/eventEmitter.js","webpack://highlighter/./src/utils/compute.js","webpack://highlighter/./src/utils/highlight.js","webpack://highlighter/./examples/findText/findText.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// @flow\n\nclass Position {\n  start: number;\n  end: number;\n  string: string;\n  constructor(start: number, end: number, string: string) {\n    this.start = start;\n    this.end = end;\n    this.string = string;\n  }\n}\n\nclass TextSearch {\n  trie: Trie;\n  constructor () {\n    this.trie = new Trie();\n  }\n\n  /**\n   * building trie\n   * @param {string[] | string} words\n   */\n  setup (words: string[] | string) {\n    const trie = this.trie, root = trie.root;\n    words = Array.isArray(words) ? words : [words];\n\n    for (let word of words) {\n      if (!trie.search(word)) {\n        trie.addWord(word);\n      }\n    }\n\n    const tmpQueue = [];\n\n    root.isRoot = true;\n    root.length = 0;\n    const setQueue = (node: TrieNode) => {\n      for (const key in node.children) {\n        node.children[key].length = node.length + 1;\n        node.children[key].pre = node;\n        tmpQueue.push(node.children[key]);\n      }\n\n      if (tmpQueue.length) {\n        setQueue(tmpQueue.shift());\n      }\n    }\n\n    setQueue(root);\n  }\n\n  find (str: string): Position[] {\n    let node = this.trie.root, results = [], result;\n    for (const [i, char] of str.split('').entries()) {\n      node = this._findNodeOfChar(node, char);\n      result = this._getPosition(node, i, str);\n      if (result) {\n        results.push(result);\n      }\n    }\n\n    return results;\n  }\n\n  _findNodeOfChar (node: TrieNode, char: string): TrieNode {\n    if (node.children[char]) {\n      return node.children[char];\n    }\n\n    if (node.isRoot) {\n      return this.trie.root;\n    }\n    return this._findNodeOfChar(node.pre, char);\n  }\n\n  _getPosition (node: TrieNode, pos: number, str: string): Position | null {\n    if (node.isEnd) {\n      const start = pos - node.length + 1;\n      const end = pos + 1;\n      const string = str.substring(start, end);\n      return new Position(start, end, string);\n    }\n\n    return null\n  }\n}\n\nclass TrieNode {\n  char: string;\n  isEnd: boolean;\n  children: { [key: any]: any; }\n  isRoot: boolean;\n  length: number;\n  pre: TrieNode;\n  constructor(char: string) {\n    this.char = char;\n    this.isEnd = false;\n    this.children = {};\n  }\n}\n\nclass Trie {\n  root: TrieNode;\n  constructor() {\n    this.root = new TrieNode('');\n  }\n\n  addWord (word: string) {\n    let current = this.root, next;\n\n    for (const char of word) {\n      next = current.children[char];\n      if (!next) {\n        current.children[char] = next = new TrieNode(char);\n      }\n      current = next;\n    }\n\n    current.isEnd = true;\n  }\n\n  search (word: string): boolean {\n    let current = this.root;\n\n    for (const char of word) {\n      if (!current.children[char]) {\n        return false\n      }\n      current = current.children[char];\n    }\n\n    return current.isEnd;\n  }\n  startsWith (word: string): boolean {\n    let current = this.root;\n\n    for (const char of word) {\n      if (!current.children[char]) {\n        return false\n      }\n\n      current = current.children[char];\n    }\n\n    return containsWords(current);\n  }\n\n  /**\n   *\n   * @param {string} word\n   */\n  removeWord (word: string) {\n    let current = this.root;\n    const hierarchy = [current];\n    const words = [];\n\n    for (let piece of word) {\n      words.unshift(piece);\n      if (!current.children[piece]) {\n        return;\n      }\n\n      current = current.children[piece];\n      hierarchy.unshift(current);\n    }\n\n    current.isEnd = false;\n\n    for (let j = 0; j < hierarchy.length; j++) {\n      if (Object.keys(hierarchy[j].children).length > 0 || hierarchy[j].isEnd) {\n        break;\n      }\n\n      if (j + 1 < hierarchy.length) {\n        delete hierarchy[j + 1].children[words[j]];\n      }\n    }\n  }\n\n}\n\nfunction containsWords (node: TrieNode): boolean {\n  if (node.isEnd) {\n    return true;\n  }\n\n  for (const key in node.children) {\n    // $FlowIgnore\n    if (Object.hasOwn(node.children, key)) {\n      if (containsWords(node.children[key])) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport default TextSearch;","// @flow\n'use strict'\n\nexport function isCharacterDataNode (node: Node | null): boolean {\n  if (!node) return false;\n  const t = node.nodeType;\n  return t === Node.TEXT_NODE || t === Node.COMMENT_NODE;\n}","// @flow\n'use strict'\n\nexport function getNodeIndex (node: Node): number {\n  let index = 0;\n  // $FlowIgnore\n  while ((node = node.previousSibling)) {\n    index++;\n  }\n\n  return index;\n}","// @flow\n'use strict'\nimport { isCharacterDataNode } from './isCharacterDataNode';\nimport { getNodeIndex } from './getNodeIndex';\n\nexport function splitNode (ancestor: any, descendant: any, descendantOffset: any): void {\n\n  let newNode, splitAtStart = (descendantOffset === 0);\n\n  if (isCharacterDataNode(descendant)) {\n    let index = getNodeIndex(descendant);\n\n    if (descendantOffset === 0) {\n      descendantOffset = index;\n\n    } else if (descendantOffset === descendant.data.length) {\n      descendantOffset = index + 1;\n    }\n    descendant = descendant.parentNode;\n  }\n\n  if (isSplitPoint(descendant, descendantOffset)) {\n    // clone empty node\n    newNode = descendant.cloneNode(false);\n    if (newNode.hasAttribute('id')) {\n      newNode.removeAttribute('id');\n    }\n    let child, newIndex = 0;\n    while ((child = descendant.childNodes[descendantOffset])) {\n      // move child to newNode\n      moveNode(child, newNode, newIndex++);\n    }\n    // move newNode to parentNode\n    moveNode(newNode, descendant.parentNode, getNodeIndex(descendant) + 1);\n  } else if (ancestor !== descendant) {\n    newNode = descendant.parentNode;\n\n    // Work out a new split point in the parent node\n    let newNodeIndex = getNodeIndex(descendant);\n\n    if (!splitAtStart) {\n      newNodeIndex++;\n    }\n    return splitNode(ancestor, newNode, newNodeIndex);\n  }\n}\n\nfunction isSplitPoint(node: Node, offset: number): boolean {\n  // Node.TEXT_NODE\n  if (isCharacterDataNode(node)) {\n    if (offset === 0) {\n      return !!node.previousSibling;\n      // $FlowIgnore\n    } else if (offset === node.length) {\n      return !!node.nextSibling;\n    } else {\n      return true;\n    }\n  }\n\n  // Node.ELEMENT_NODE\n  return offset > 0 && offset < node.childNodes.length;\n}\nexport function removeNode (node: Node): Node | null {\n  const p = node.parentNode;\n  if (p) {\n    return p.removeChild(node);\n  }\n\n  return null;\n}\n\nexport function moveNode (node: Node, newNode: Node, newIndex: number): void {\n  if (newIndex === -1) {\n    newIndex = newNode.childNodes.length;\n  }\n\n  if (newIndex === newNode.childNodes.length) {\n    newNode.appendChild(node);\n  } else {\n    newNode.insertBefore(node, newNode.childNodes[newIndex]);\n  }\n}","// @flow\n'use strict'\n\nconst classListSupport = !(typeof document.createElement('span').classList !== 'undefined');\nconst classNameSupport = !(typeof document.createElement('span').className !== 'undefined');\n\n// $FlowIgnore\nexport const rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\nexport function stripAndCollapse (value: string): string {\n  const tokens = value.match(rnothtmlwhite) || [];\n  return tokens.join(' ');\n}\n\n/**\n *\n * @param {string|Array} value\n * @return {string[]}\n */\nexport function classesToArray (value: string | Array<string>): string[] {\n  if (Array.isArray(value)) {\n    return value;\n  }\n  if (typeof value === 'string') {\n    return value.match(rnothtmlwhite) || [];\n  }\n  return [];\n}\n\n/**\n *\n * @param {HTMLElement} el\n * @param {string} value\n */\nexport function toggleClass (el: HTMLElement, value: string): boolean {\n  const classNames = classesToArray(value);\n\n  if (classNames.length && el.nodeType === Node.ELEMENT_NODE) {\n    classNames.forEach(className => {\n      if (classListSupport) {\n        el.classList.toggle(className);\n      } else {\n        if (hasClass(el, className)) {\n          removeClass(el, className);\n        } else {\n          addClass(el, className);\n        }\n      }\n    });\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n *\n * @param {HTMLElement} el\n * @return {string}\n */\nexport function getClass (el: HTMLElement): string {\n\n  if (el.nodeType !== Node.ELEMENT_NODE) {\n    return '';\n  }\n\n  if (classNameSupport) {\n    return el.className;\n  }\n\n  return el.getAttribute('class') || '';\n}\n\n/**\n *\n */\nexport function hasClass (el: HTMLElement, value: string): boolean {\n\n  if (el.nodeType !== Node.ELEMENT_NODE) {\n    return false;\n  }\n\n  if (classListSupport) {\n    return el.classList.contains(value);\n  }\n  const classNames = classesToArray(getClass(el));\n  return classNames.indexOf(value) > -1;\n}\n\n/**\n *\n * @param {HTMLElement | Node} el\n * @param {string} value\n */\nexport function addClass (el: HTMLElement, value: string): void {\n\n  let classNames = classesToArray(value), curClass, cur, final;\n\n  if (classNames.length && el.nodeType === Node.ELEMENT_NODE) {\n    if (classListSupport) {\n      el.classList.add(...classNames);\n    } else {\n      curClass = getClass(el);\n      cur = ' ' + stripAndCollapse(curClass) + ' ';\n      classNames.forEach(className => {\n        if (cur.indexOf(' ' + className + ' ') < 0) {\n          cur += className + ' '\n        }\n      });\n\n      final = stripAndCollapse(cur);\n\n      if (curClass !== final) {\n        if (classNameSupport) {\n          el.className = final;\n        } else {\n          el.setAttribute('class', final);\n        }\n      }\n    }\n  }\n}\n\n/**\n *\n * @param {HTMLElement | Node} el\n * @param {string} [value]\n */\nexport function removeClass (el: HTMLElement, value: string): void {\n\n  let classNames = classesToArray(value), curClass, cur, final,\n    isElement = (el.nodeType === Node.ELEMENT_NODE);\n\n  if (arguments.length < 2 && isElement) {\n    return el.removeAttribute('class');\n  }\n\n  if (classNames.length && isElement) {\n    if (classListSupport) {\n      el.classList.remove(...classNames);\n    } else {\n      curClass = getClass(el);\n      cur = ' ' + stripAndCollapse(curClass) + ' ';\n      classNames.forEach(className => {\n        while (cur.indexOf(' ' + className + ' ') > -1) {\n          cur = cur.replace(' ' + className + ' ', ' ');\n        }\n      });\n\n      final = stripAndCollapse(cur);\n      if (curClass !== final) {\n        if (classNameSupport) {\n          el.className = final;\n        } else {\n          el.setAttribute('class', final);\n        }\n      }\n    }\n  }\n}\n","// @flow\n'use strict'\n\nimport { hasClass } from './classes';\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} node\n * @return {Node | null}\n */\nexport function findClosestAncestor (ancestor: Node, node: Node): Node | null {\n  let p;\n  while (node) {\n    p = node.parentNode;\n    if (p === ancestor) {\n      return node\n    }\n    // $FlowIgnore\n    node = p;\n  }\n\n  return null;\n}\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} descendant\n * @param {boolean} selfIsAncestor\n */\nexport function isAncestorOf (ancestor: Node, descendant: Node, selfIsAncestor: boolean): boolean {\n  let n = selfIsAncestor ? descendant : descendant.parentNode;\n  while (n) {\n    if (n === ancestor) {\n      return true;\n    } else {\n      n = n.parentNode;\n    }\n  }\n  return false;\n}\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} descendant\n * @return {boolean}\n */\nexport function isOrIsAncestorOf(ancestor: Node, descendant: Node): boolean {\n  return isAncestorOf(ancestor, descendant, true);\n}\n\nexport function findSelfOrAncestorWithClass (node: Node, className: string): Node | null {\n  while (node) {\n    // $FlowIgnore\n    if (hasClass(node, className)) {\n      return node;\n    }\n    // $FlowIgnore\n    node = node.parentNode;\n  }\n  return null;\n}\n\n","// @flow\n'use strict'\n\n/**\n * The element node returns the child node length, and the text node returns the text length\n * @param {Node|Text} node\n */\n\nimport { isCharacterDataNode } from './isCharacterDataNode';\n\nexport function getNodeLength (node: Node): number {\n  const t = node.nodeType;\n  if (t === Node.ELEMENT_NODE) {\n    return node.childNodes.length;\n  } else if (isCharacterDataNode(node)) {\n    // $FlowIgnore\n    return node.length;\n  }\n  return 0;\n}","// @flow\n\nimport * as crudNode from './crudNode';\nimport * as classes from './classes';\nimport * as findClosestAncestor from './findClosestAncestor';\nimport { isCharacterDataNode } from './isCharacterDataNode';\nimport { getNodeIndex } from './getNodeIndex';\nimport { getNodeLength } from './getNodeLength';\n\nexport default {\n  ...crudNode,\n  ...classes,\n  ...findClosestAncestor,\n  isCharacterDataNode,\n  getNodeIndex,\n  getNodeLength,\n  getSelection\n};","// @flow\n'use strict'\nimport { getNodeLength } from '../dom-utils/getNodeLength';\n\nexport function setRange (range: Range, ...args: Array<any>) {\n  let sc = args[0], so = args[1], ec, eo;\n  const len = getNodeLength(sc);\n\n  switch (args.length) {\n    case 2:\n      ec = sc;\n      eo = len;\n      break;\n    case 3:\n      ec = args[2];\n      eo = so;\n      break;\n    case 4:\n      ec = args[2];\n      eo = args[3];\n      break;\n  }\n\n  range.setStart(sc, so);\n  // $FlowIgnore\n  range.setEnd(ec, eo);\n}\n","// @flow\n'use strict'\n\n/**\n * Returns the part of a specified range that intersects another range\n */\nexport function getIntersectionRange (rangeA: Range, rangeB: Range): Range | null {\n  if (intersectsRange(rangeA, rangeB)) {\n    const range = rangeA.cloneRange();\n    // $FlowIgnore\n    if (range.compareBoundaryPoints(rangeB.START_TO_START, rangeB) === -1) {\n      range.setStart(rangeB.startContainer, rangeB.startOffset);\n    }\n    // $FlowIgnore\n    if (range.compareBoundaryPoints(rangeB.END_TO_END, rangeB) === 1) {\n      range.setEnd(rangeB.endContainer, rangeB.endOffset);\n    }\n\n    return range;\n  }\n\n  return null;\n}\n\n/**\n * Returns a boolean indicating whether the given Range intersects the Range.\n */\nexport function intersectsRange (rangeA: Range, rangeB: Range): boolean {\n  // rangeA.s < rangeB.e;\n  // $FlowIgnore\n  const start = rangeA.compareBoundaryPoints(rangeB.END_TO_START, rangeB);\n  // rangeA.e > rangeB.s;\n  // $FlowIgnore\n  const end = rangeA.compareBoundaryPoints(rangeB.START_TO_END, rangeB);\n\n  return start < 0 && end > 0;\n}","// @flow\n'use strict'\n\nimport { isCharacterDataNode } from '../dom-utils/isCharacterDataNode';\nimport { findClosestAncestor, isOrIsAncestorOf } from '../dom-utils/findClosestAncestor';\nimport { getNodeLength } from '../dom-utils/getNodeLength';\nimport { setRange } from './setRange';\n\nexport class RangeIterator {\n  range: Range;\n  clonePartiallySelectedTextNodes: boolean;\n  root: Node;\n  sc: Node;\n  so: number;\n  ec: Node;\n  eo: number;\n  _current: Node | null = null;\n  _end: Node | null = null;\n  _next: Node | null = null;\n  constructor(range: Range, clonePartiallySelectedTextNodes?: boolean = false) {\n    this.range = range;\n    this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n    if (!this.range.collapsed) {\n      this.root = this.range.commonAncestorContainer;\n      this.sc = this.range.startContainer;\n      this.so = this.range.startOffset;\n      this.ec = this.range.endContainer;\n      this.eo = this.range.endOffset;\n\n      if (this.sc === this.ec && isCharacterDataNode(this.sc)) {\n        this._next = this._end = this.sc;\n      } else {\n        this._next = this.sc === this.root && !isCharacterDataNode(this.sc)\n          ? this.sc.childNodes[this.so] : findClosestAncestor(this.root, this.sc)\n\n        this._end = this.ec === this.root && !isCharacterDataNode(this.ec)\n          ? this.ec.childNodes[this.eo - 1] : findClosestAncestor(this.root, this.ec);\n      }\n    }\n\n  }\n  next (): Node | null {\n    let current = this._current = this._next;\n    // $FlowIgnore\n    this._next = this._current != null && this._current !== this._end ? this._current.nextSibling : null;\n\n    // Check for partially selected text nodes\n    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n      // clone partially selected text nodes\n      // return cloneNode\n      if (current === this.ec) {\n        // $FlowIgnore\n        (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n      }\n\n      if (current === this.sc) {\n        // $FlowIgnore\n        (current = current.cloneNode(true)).deleteData(0, this.so);\n      }\n    }\n\n    return current;\n  }\n\n  isPartiallySelectedSubtree (): boolean {\n    return !isCharacterDataNode(this._current) &&\n      // $FlowIgnore\n      (isOrIsAncestorOf(this._current, this.sc) || isOrIsAncestorOf(this._current, this.ec));\n  }\n\n  getSubtreeIterator (): RangeIterator {\n    const range = document.createRange(), current = this._current;\n    // $FlowIgnore\n    let startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);\n\n    if (current) {\n      if (isOrIsAncestorOf(current, this.sc)) {\n        startContainer = this.sc;\n        startOffset = this.so;\n      }\n      if (isOrIsAncestorOf(current, this.ec)) {\n        endContainer = this.ec;\n        endOffset = this.eo;\n      }\n    }\n\n    setRange(range, startContainer, startOffset, endContainer, endOffset);\n\n    return new RangeIterator(range, this.clonePartiallySelectedTextNodes);\n  }\n}\n\nexport function iterateSubtree (it: RangeIterator, cb: (node: Node) => void) {\n  let node;\n  while((node = it.next())) {\n    if (it.isPartiallySelectedSubtree()) {\n      const subIt = it.getSubtreeIterator();\n      iterateSubtree(subIt, cb);\n    } else {\n      const nit = document.createNodeIterator(node);\n      while((node = nit.nextNode())) {\n        cb(node);\n      }\n    }\n  }\n}","// @flow\n'use strict'\n\nimport { RangeIterator, iterateSubtree } from './rangeIterator';\nimport { getIntersectionRange } from './intersection';\n\nexport function getNodes (range: Range, nodeTypes?: Array<number>, filter?: (node: Node) => boolean): Node[] {\n  let nodes = [], regx;\n  if (nodeTypes && nodeTypes.length) {\n    regx = new RegExp(`(${nodeTypes.join('|')})$`);\n  }\n\n  iterateSubtree(new RangeIterator(range, false), (node) => {\n    if (regx && !regx.test(node.nodeType.toString())) {\n      return;\n    }\n\n    if (typeof filter == 'function' && !filter(node)) {\n      return;\n    }\n\n    nodes.push(node);\n  });\n\n  return nodes;\n}\n\n/**\n * range (prev/next) point (last/first)\n * @param range\n */\nexport function getEffectiveTextNodes (range: Range): Node[] {\n  const textNodes = getNodes(range, [Node.TEXT_NODE]);\n\n  let start = 0, end = textNodes.length, node;\n\n  // remove invalid text nodes from left to right\n  while ((node = textNodes[start]) && !rangeSelectsAnyText(range, node)) {\n    ++start;\n  }\n\n  // remove invalid text nodes from right to left\n  while ((node = textNodes[end - 1]) && !rangeSelectsAnyText(range, node)) {\n    --end;\n  }\n\n  return textNodes.slice(start, end);\n}\n\n\nfunction rangeSelectsAnyText(range: Range, textNode: Node): boolean {\n  const textNodeRange = document.createRange();\n  textNodeRange.selectNodeContents(textNode);\n  const intersectionRange = getIntersectionRange(textNodeRange, range);\n  const text = intersectionRange ? intersectionRange.toString() : '';\n  return text !== '';\n}\n","// @flow\n'use strict'\n\nexport function getSelection (sel?: any): Selection {\n  if (sel instanceof Selection) {\n    return sel;\n  }\n\n  return window.getSelection();\n}\n\nexport function getRangesInSelection (selection: Selection): Range[] {\n  const ranges = [];\n  for (let i = 0; i < selection.rangeCount; ++i) {\n    ranges.push(selection.getRangeAt(i));\n  }\n\n  return ranges;\n}","// @flow\n'use strict'\nimport { setRange } from './setRange';\nimport * as intersection from './intersection';\nimport * as getNodes from './getNodes';\nimport * as rangeIterator from './rangeIterator';\nimport { splitRangeBoundaries } from './splitRangeBoundaries';\nimport * as selection from './selection';\n\nexport default {\n  ...intersection,\n  ...getNodes,\n  ...rangeIterator,\n  ...selection,\n  splitRangeBoundaries,\n  setRange\n}","// @flow\n'use strict'\n\nimport { isCharacterDataNode } from '../dom-utils/isCharacterDataNode';\nimport { getNodeIndex } from '../dom-utils/getNodeIndex';\n\nexport function splitRangeBoundaries (range: Range): void {\n  let [sc, so, ec, eo] = [range.startContainer, range.startOffset, range.endContainer, range.endOffset];\n  const startSameEnd: boolean = (sc === ec);\n  // $FlowIgnore\n  if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n    // $FlowIgnore\n    ec.splitText(eo);\n  }\n  // $FlowIgnore\n  if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n    // $FlowIgnore\n    sc = sc.splitText(so);\n    if (startSameEnd) {\n      eo -= so;\n      ec = sc;\n    } else if (ec === sc.parentNode && eo <= getNodeIndex(sc)) {\n      eo++;\n    }\n    so = 0;\n  }\n}","// @flow\n'use strict'\n\nimport type { Obj } from '../types';\nexport function each (obj: Obj, callback: (propName: any, propValue: any) => boolean | void): Obj {\n  for (let i in obj) {\n    if (callback.call(obj[i], i, obj[i]) === false) {\n      break;\n    }\n  }\n\n  return obj;\n}","// @flow\n'use strict'\n\nimport type { RefillsOptions, DefaultRefillsOptions } from './types';\nimport domUtils from './dom-utils';\nimport rangeUtils from './range-utils';\nimport { createRefillsOptions } from './utils/createOptions';\nimport { each } from './utils/each';\n\nexport default class Refills {\n  options: DefaultRefillsOptions;\n  constructor(options?: RefillsOptions) {\n    this.options = createRefillsOptions(options);\n  }\n\n  appliesToRange (range: Range): void {\n    rangeUtils.splitRangeBoundaries(range);\n\n    const textNodes = rangeUtils.getEffectiveTextNodes(range);\n    if (textNodes.length) {\n      textNodes.forEach(textNode => {\n        if (this.options.className && !domUtils.findSelfOrAncestorWithClass(textNode, this.options.className)) {\n          this.appliesToTextNode(textNode);\n        }\n      });\n\n      const lastTextNode = textNodes[textNodes.length - 1];\n      // $FlowIgnore\n      rangeUtils.setRange(range, textNodes[0], 0, lastTextNode, lastTextNode.length);\n      if (this.options.normalize) {\n        this.normalize(textNodes, range, false);\n      }\n    }\n  }\n\n  appliesToTextNode (textNode: Node): void {\n    const parentNode = textNode.parentNode;\n    if (textNode.nodeType === Node.TEXT_NODE && parentNode) {\n      const el = this.createElement();\n      if (el) {\n        parentNode.insertBefore(el, textNode);\n        el.appendChild(textNode);\n      }\n    }\n  }\n\n  wipeToRange (range: Range): void {\n    rangeUtils.splitRangeBoundaries(range);\n\n    const textNodes = rangeUtils.getEffectiveTextNodes(range);\n\n    if (textNodes.length) {\n      // split boundaries ancestor with class\n      splitBoundariesAncestorWithClass(range, this.options.className);\n      textNodes.forEach(textNode => {\n        let ancestorWithClass = domUtils.findSelfOrAncestorWithClass(textNode, this.options.className);\n        if (ancestorWithClass) {\n          this.wipeToAncestor(ancestorWithClass);\n        }\n      });\n\n      const lastTextNode = textNodes[textNodes.length - 1];\n      // $FlowIgnore\n      rangeUtils.setRange(range, textNodes[0], 0, lastTextNode, lastTextNode.length);\n      if (this.options.normalize) {\n        this.normalize(textNodes, range, true);\n      }\n    }\n  }\n\n  wipeToAncestor (ancestor: any): void {\n    if (this.isEqualNode(ancestor)) {\n      let child, index = domUtils.getNodeIndex(ancestor);\n      const parentNode = ancestor.parentNode;\n\n      while ((child = ancestor.firstChild)) {\n        // move children to sibling\n        domUtils.moveNode(child, parentNode, index++);\n      }\n\n      domUtils.removeNode(ancestor);\n    } else {\n      domUtils.removeClass(ancestor, this.options.className);\n    }\n  }\n\n  createElement (): HTMLElement | null {\n    if (this.options.tagName) {\n      const el = document.createElement(this.options.tagName);\n      if (this.options.className && this.options.elAttrs && this.options.elProps) {\n        domUtils.addClass(el, this.options.className);\n        // $FlowIgnore\n        mapAttrs(el, this.options.elAttrs);\n        // $FlowIgnore\n        mapProps(el, this.options.elProps);\n      }\n      return el;\n    }\n\n    return null;\n  }\n\n  normalize (textNodes: Node[], range: Range, isUndo: boolean): void {\n    let firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];\n\n    let currentMerge = null, merges = [];\n\n    let rangeStartNode = firstNode, rangeEndNode = lastNode;\n    // $FlowIgnore\n    let rangeStartOffset = 0, rangeEndOffset = lastNode.length;\n\n    textNodes.forEach(textNode => {\n      // go through each textNode and find the mergable node in front of them,\n      const precedingNode = getPrecedingMrTextNode(textNode, !isUndo, (node) => {\n        return this.isEqualNode(node);\n      });\n\n      if (precedingNode) {\n        // create a Merge object headed by precedingNode\n        if (currentMerge == null) {\n          currentMerge = new Merge(precedingNode);\n          merges.push(currentMerge);\n        }\n        // $FlowIgnore\n        currentMerge.textNodes.push(textNode);\n\n        if (rangeStartNode === textNode) {\n          // $FlowIgnore\n          rangeStartNode = currentMerge.textNodes[0];\n          // $FlowIgnore\n          rangeStartOffset = rangeStartNode.length;\n        }\n\n        if (rangeEndNode === textNode) {\n          // $FlowIgnore\n          rangeEndNode = currentMerge.textNodes[0];\n          // $FlowIgnore\n          rangeEndOffset = currentMerge.getLength();\n        }\n\n      } else {\n        // reset the current Merge object to create a new merge\n        currentMerge = null;\n      }\n    });\n\n    const nextNode = getNextMrTextNode(lastNode, !isUndo, (node) => {\n      return this.isEqualNode(node);\n    });\n\n    if (nextNode) {\n      if (currentMerge == null) {\n        currentMerge = new Merge(lastNode);\n        merges.push(currentMerge);\n      }\n      // $FlowIgnore\n      currentMerge.textNodes.push(nextNode);\n    }\n\n    if (merges.length) {\n      merges.forEach(merge => merge.start());\n\n      rangeUtils.setRange(range, rangeStartNode, rangeStartOffset, rangeEndNode, rangeEndOffset);\n    }\n  }\n\n  isEqualNode (node: Node): boolean {\n    const newNode = this.createElement();\n    if (newNode) {\n      return newNode.cloneNode(false).isEqualNode(node.cloneNode(false));\n    }\n    return false;\n  }\n}\n\nfunction mapAttrs (el: HTMLElement, attrs: Object) {\n  each(attrs, function (attrName, attrValue) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (attrs.hasOwnProperty(attrName) && !/^class(?:Name)?$/i.test(attrName)) {\n      el.setAttribute(attrName, attrValue);\n    }\n  });\n}\n\nfunction mapProps (el: HTMLElement, props: Object) {\n  each(props, function (propName, propValue) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (props.hasOwnProperty(propName)) {\n      if (propName === 'className') {\n        domUtils.addClass(el, propValue);\n      } else {\n        // $FlowIgnore\n        el[propName] = propValue;\n      }\n    }\n  });\n}\n\nconst getPrecedingMrTextNode = getter(false);\n\nconst getNextMrTextNode = getter(true);\nfunction getter (forward: boolean): ((textNode: Node, checkParentElement: boolean, filter?: (node: Node) => boolean) => Node | null) {\n  const adjacentPropName = forward ? 'nextSibling' : 'previousSibling';\n  const position = forward ? 'firstChild' : 'lastChild';\n  return function (textNode, checkParentElement, filter) {\n    // $FlowIgnore\n    let adjacentNode = textNode[adjacentPropName], parentNode = textNode.parentNode;\n\n    if (adjacentNode && adjacentNode.nodeType === Node.TEXT_NODE) {\n      return adjacentNode\n    } else if (checkParentElement) {\n      // $FlowIgnore\n      adjacentNode = parentNode[adjacentPropName];\n      if (adjacentNode && adjacentNode.nodeType === Node.ELEMENT_NODE) {\n        if (filter && !filter(adjacentNode)) {\n          return null;\n        }\n        let adjacentNodeChild = adjacentNode[position];\n        if (adjacentNodeChild && adjacentNodeChild.nodeType === Node.TEXT_NODE) {\n          return adjacentNodeChild\n        }\n      }\n    }\n\n    return null\n  }\n}\n\nfunction splitBoundariesAncestorWithClass (range: Range, className: string): void {\n  [{ node: range.endContainer, offset: range.endOffset }, { node: range.startContainer, offset: range.startOffset }]\n    .forEach(({ node, offset }) => {\n      const ancestorWithClass = domUtils.findSelfOrAncestorWithClass(node, className);\n      if (ancestorWithClass) {\n        domUtils.splitNode(ancestorWithClass, node, offset);\n      }\n    });\n}\n\nclass Merge {\n  firstTextNode: Node;\n  textNodes: Node[];\n  constructor(node: Node) {\n    const n = node.nodeType === Node.ELEMENT_NODE ? node.firstChild : node;\n    if (n) {\n      this.firstTextNode = n;\n      this.textNodes = [n];\n    }\n  }\n\n  start (): string {\n    const textParts = [];\n    this.textNodes.forEach((textNode, index) => {\n      const parentNode = textNode.parentNode;\n      if (index > 0 && parentNode) {\n        domUtils.removeNode(textNode);\n        if (!parentNode.hasChildNodes()) {\n          domUtils.removeNode(parentNode);\n        }\n      }\n      // $FlowIgnore\n      textParts.push(textNode.data);\n    });\n    // $FlowIgnore\n    this.firstTextNode.data = textParts.join('');\n    return this.firstTextNode.data;\n  }\n\n  getLength (): number {\n    let len = 0;\n    this.textNodes.forEach(textNode => {\n      // $FlowIgnore\n      len += textNode.length;\n    });\n    return len;\n  }\n}","// @flow\n\n'use strict'\nimport type { RefillsOptions, DefaultRefillsOptions } from '../types';\n\nimport { each } from './each';\nexport function createRefillsOptions (options?: RefillsOptions = {}): DefaultRefillsOptions {\n  const defaultOptions = {\n    tagName: 'span',\n    className: 'highlight',\n    elAttrs: {},\n    elProps: {},\n    normalize: true\n  }\n\n  each(options, (propName, propValue) => {\n    // eslint-disable-next-line no-prototype-builtins\n    if (options.hasOwnProperty(propName)) {\n      defaultOptions[propName] = propValue;\n    }\n  });\n\n  return defaultOptions;\n}\n\n","// @flow\n'use strict'\nimport rangeUtils from '../range-utils';\n\nexport default class CharacterRange {\n\n  start: number;\n  end: number;\n  referenceNode: Node;\n  isCollapsed: boolean;\n  constructor(start: number, end: number, referenceNode: Node) {\n    this.start = start;\n    this.end = end;\n    this.referenceNode = referenceNode;\n    this.isCollapsed = this.start === this.end;\n  }\n\n  _createRelativeCharacterRange (characterRange: CharacterRange): CharacterRange {\n    if (characterRange.referenceNode !== this.referenceNode) {\n      return CharacterRange.fromRange(characterRange.toRange(), this.referenceNode);\n    }\n\n    return characterRange;\n  }\n  isEqual (another: CharacterRange): boolean {\n    another = this._createRelativeCharacterRange(another);\n    return this.start === another.start && this.end === another.end;\n  }\n\n  isIntersects (another: CharacterRange): boolean {\n    another = this._createRelativeCharacterRange(another);\n    return this.start < another.end && this.end > another.start;\n  }\n\n  isAdjoin (another: CharacterRange): boolean {\n    another = this._createRelativeCharacterRange(another);\n    return this.start === another.end || this.end === another.start\n  }\n\n  union (another: CharacterRange): CharacterRange | null {\n    another = this._createRelativeCharacterRange(another);\n    if (this.isIntersects(another) || this.isAdjoin(another)) {\n      return new CharacterRange(Math.min(this.start, another.start), Math.max(this.end, another.end), this.referenceNode);\n    }\n    return null\n  }\n\n  intersection (another: CharacterRange): CharacterRange | null {\n    another = this._createRelativeCharacterRange(another);\n    if (this.isIntersects(another)) {\n      return new CharacterRange(Math.max(this.start, another.start), Math.min(this.end, another.end), this.referenceNode);\n    }\n\n    return null;\n  }\n\n  complementarySet (another: CharacterRange): CharacterRange[] {\n    const characterRanges = [];\n    another = this._createRelativeCharacterRange(another);\n\n    if (this.start < another.start) {\n      characterRanges.push(new CharacterRange(this.start, another.start, this.referenceNode));\n    }\n\n    if (this.end > another.end) {\n      characterRanges.push(new CharacterRange(another.end, this.end, this.referenceNode));\n    }\n\n    return characterRanges;\n  }\n\n  toRange (): Range {\n    const range = document.createRange();\n    const { start, end } = this;\n    range.setStart(this.referenceNode, 0);\n    range.collapse(true);\n\n    const nodeIterator = document.createNodeIterator(this.referenceNode, NodeFilter.SHOW_TEXT);\n    let textNode, charIndex = 0, nextCharIndex;\n\n    let foundStart = false, foundEnd = false;\n    while (!foundEnd && (textNode = nodeIterator.nextNode()) && textNode) {\n      nextCharIndex = charIndex + textNode.length;\n      if (!foundStart && start >= charIndex && start <= nextCharIndex) {\n        range.setStart(textNode, start - charIndex);\n        foundStart = true;\n      }\n\n      if (end >= charIndex && end <= nextCharIndex) {\n        range.setEnd(textNode, end - charIndex);\n        foundEnd = true;\n      }\n      charIndex = nextCharIndex;\n    }\n\n    return range;\n  }\n  static fromRange (range: Range, referenceNode: Node): CharacterRange {\n    const wrapRange = range.cloneRange();\n    wrapRange.selectNodeContents(referenceNode);\n\n    const intersectionRange = rangeUtils.getIntersectionRange(wrapRange, range);\n    let start = 0, end = 0;\n    if (intersectionRange) {\n      wrapRange.setEnd(intersectionRange.startContainer, intersectionRange.startOffset);\n      start = wrapRange.toString().length;\n      end = start + intersectionRange.toString().length\n    }\n\n    return new CharacterRange(start, end, referenceNode);\n\n  }\n  static fromSelection (sel: Selection, referenceNode: HTMLElement | Node): CharacterRange[] {\n    const characterRanges = []\n    rangeUtils.getRangesInSelection(sel).forEach(range => {\n      characterRanges.push(CharacterRange.fromRange(range, referenceNode));\n    });\n\n    return characterRanges;\n  }\n}","// @flow\n/* global $Values */\n'use strict'\n\ntype Listener = (...args: Array<any>) => void;\ntype ListenerMap = { [key: string]: Listener };\nconst apply = Function.prototype.apply, call = Function.prototype.call;\nexport default class EventEmitter<U: ListenerMap> {\n  __events__: Object;\n  constructor() {\n    this.__events__ = {};\n  }\n\n  on<T: string> (type: T, listener: $Values<U>): EventEmitter<U> {\n    const data = this.__events__;\n    if (!data[type]) data[type] = listener;\n    else if (typeof data[type] === 'object') data[type].push(listener);\n    else data[type] = [data[type], listener];\n\n    return this;\n  }\n\n  once<T: string> (type: T, listener: $Values<U>): EventEmitter<U> {\n    let once, self;\n\n    self = this;\n    // $FlowIgnore\n    self.on.call(self, type, once = function () {\n      // $FlowIgnore\n      self.off.call(self, type, once);\n      apply.call(listener, self, arguments);\n    });\n    // $FlowIgnore\n    once.__onceListener__ = listener;\n    return this;\n  }\n\n  off<T: string> (type: T, listener: $Values<U>): EventEmitter<U> {\n    const data = this.__events__;\n    if (!data[type]) return this;\n\n    const listeners = data[type];\n\n    if (typeof listeners === 'object') {\n      for (let i = 0, candidate; (candidate = listeners[i]); ++i) {\n        if ((candidate === listener) ||\n          (candidate.__onceListener__ === listener)) {\n          if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n          else listeners.splice(i, 1);\n        }\n      }\n    } else {\n      if ((listeners === listener) ||\n        (listeners.__onceListener__ === listener)) {\n        delete data[type];\n      }\n    }\n\n    return this;\n  }\n\n  emit<T: string> (type: T, ...args: Array<any>): void {\n    let listeners = this.__events__[type];\n    if (!listeners) return;\n\n    let l, i;\n\n    if (typeof listeners === 'object') {\n      l = arguments.length;\n      args = new Array(l - 1);\n      for (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n      listeners = listeners.slice();\n      for (let i = 0, listener; (listener = listeners[i]); ++i) {\n        apply.call(listener, this, args);\n      }\n    } else {\n      switch (arguments.length) {\n        case 1:\n          call.call(listeners, this);\n          break;\n        case 2:\n          call.call(listeners, this, arguments[1]);\n          break;\n        case 3:\n          call.call(listeners, this, arguments[1], arguments[2]);\n          break;\n        default:\n          l = arguments.length;\n          args = new Array(l - 1);\n          for (i = 1; i < l; ++i) {\n            args[i - 1] = arguments[i];\n          }\n          apply.call(listeners, this, args);\n      }\n    }\n  }\n}","// @flow\n'use strict'\n\nexport type Options = {|\n  scrollMode?: 'always' | 'if-needed';\n  block?: 'center' | 'end' | 'nearest' | 'start';\n  inline?: 'center' | 'end' | 'nearest' | 'start';\n|}\n\nexport type ScrollAction = {\n  el: HTMLElement;\n  top: number;\n  left: number;\n}\n\nexport function compute (target: Range, options: Options): ScrollAction[] {\n  const { block, inline, scrollMode } = options;\n  let scrollingElement = document.scrollingElement || document.documentElement;\n\n  let frames: HTMLElement[] = [];\n  let cursor = isElement(target.commonAncestorContainer);\n  while (cursor) {\n    if (cursor === scrollingElement) {\n      frames.push(cursor);\n      break;\n    }\n\n    if (\n      cursor === document.body &&\n      isScrollable(cursor) &&\n      // $FlowIgnore\n      !isScrollable(document.documentElement)\n    ) {\n      continue\n    }\n\n    if (cursor != null && isScrollable(cursor)) {\n      frames.push(cursor)\n    }\n    // $FlowIgnore\n    cursor = cursor.parentElement;\n  }\n  let viewportWidth = window.visualViewport?.width ?? window.innerWidth;\n  let viewportHeight = window.visualViewport?.height ?? window.innerHeight;\n  let { scrollX, scrollY } = window\n\n  let {\n    height: targetHeight,\n    width: targetWidth,\n    top: targetTop,\n    right: targetRight,\n    bottom: targetBottom,\n    left: targetLeft,\n  } = target.getBoundingClientRect();\n\n  let targetBlock: number =\n    block === 'start' || block === 'nearest'\n      ? targetTop\n      : block === 'end'\n        ? targetBottom\n        : targetTop + targetHeight / 2\n\n  let targetInline: number =\n    inline === 'center'\n      ? targetLeft + targetWidth / 2\n      : inline === 'end'\n        ? targetRight\n        : targetLeft\n\n  const computations = [];\n  frames.forEach(frame => {\n    let { height, width, top, right, bottom, left } =\n      frame.getBoundingClientRect()\n\n    if (\n      scrollMode === 'if-needed' &&\n      targetTop >= 0 &&\n      targetLeft >= 0 &&\n      targetBottom <= viewportHeight &&\n      targetRight <= viewportWidth &&\n      targetTop >= top &&\n      targetBottom <= bottom &&\n      targetLeft >= left &&\n      targetRight <= right\n    ) {\n      return computations\n    }\n\n    let frameStyle = getComputedStyle(frame)\n    let borderLeft = parseInt(frameStyle.borderLeftWidth, 10)\n    let borderTop = parseInt(frameStyle.borderTopWidth, 10)\n    let borderRight = parseInt(frameStyle.borderRightWidth, 10)\n    let borderBottom = parseInt(frameStyle.borderBottomWidth, 10)\n\n    let blockScroll: number = 0\n    let inlineScroll: number = 0\n\n    let scrollbarWidth =\n      'offsetWidth' in frame\n        ? frame.offsetWidth -\n        frame.clientWidth -\n        borderLeft -\n        borderRight\n        : 0\n    let scrollbarHeight =\n      'offsetHeight' in frame\n        ? frame.offsetHeight -\n        frame.clientHeight -\n        borderTop -\n        borderBottom\n        : 0\n\n    let scaleX =\n      'offsetWidth' in frame\n        ? frame.offsetWidth === 0\n          ? 0\n          : width / frame.offsetWidth\n        : 0\n    let scaleY =\n      'offsetHeight' in frame\n        ? frame.offsetHeight === 0\n          ? 0\n          : height / frame.offsetHeight\n        : 0\n\n\n    if (scrollingElement === frame) {\n      if (block === 'start') {\n        blockScroll = targetBlock\n      } else if (block === 'end') {\n        blockScroll = targetBlock - viewportHeight\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(\n          scrollY,\n          scrollY + viewportHeight,\n          viewportHeight,\n          borderTop,\n          borderBottom,\n          scrollY + targetBlock,\n          scrollY + targetBlock + targetHeight,\n          targetHeight\n        )\n      } else {\n        blockScroll = targetBlock - viewportHeight / 2\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - viewportWidth / 2\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - viewportWidth\n      } else {\n        inlineScroll = alignNearest(\n          scrollX,\n          scrollX + viewportWidth,\n          viewportWidth,\n          borderLeft,\n          borderRight,\n          scrollX + targetInline,\n          scrollX + targetInline + targetWidth,\n          targetWidth\n        )\n      }\n\n      blockScroll = Math.max(0, blockScroll + scrollY)\n      inlineScroll = Math.max(0, inlineScroll + scrollX)\n    } else {\n      if (block === 'start') {\n        blockScroll = targetBlock - top - borderTop\n      } else if (block === 'end') {\n        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(\n          top,\n          bottom,\n          height,\n          borderTop,\n          borderBottom + scrollbarHeight,\n          targetBlock,\n          targetBlock + targetHeight,\n          targetHeight\n        )\n      } else {\n        blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline - left - borderLeft\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - right + borderRight + scrollbarWidth\n      } else {\n        inlineScroll = alignNearest(\n          left,\n          right,\n          width,\n          borderLeft,\n          borderRight + scrollbarWidth,\n          targetInline,\n          targetInline + targetWidth,\n          targetWidth\n        )\n      }\n\n      let { scrollLeft, scrollTop } = frame\n      blockScroll = Math.max(\n        0,\n        Math.min(\n          scrollTop + blockScroll / scaleY,\n          frame.scrollHeight - height / scaleY + scrollbarHeight\n        )\n      )\n      inlineScroll = Math.max(\n        0,\n        Math.min(\n          scrollLeft + inlineScroll / scaleX,\n          frame.scrollWidth - width / scaleX + scrollbarWidth\n        )\n      )\n      targetBlock += scrollTop - blockScroll\n      targetInline += scrollLeft - inlineScroll\n    }\n\n    computations.push({ el: frame, top: blockScroll, left: inlineScroll })\n  })\n  return computations;\n}\n\nfunction isElement (el: any): HTMLElement | null {\n  if (el && el.nodeType === Node.ELEMENT_NODE) {\n    return el;\n  }\n\n  return null\n}\n\nfunction canOverflow (\n  overflow: string | null,\n) {\n  if (overflow === 'hidden') {\n    return false\n  }\n\n  return overflow !== 'visible' && overflow !== 'clip'\n}\n\nfunction isScrollable (el: HTMLElement): boolean {\n  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {\n    let style = getComputedStyle(el)\n    return (\n      canOverflow(style.overflowY) ||\n      canOverflow(style.overflowX) ||\n      isHiddenByFrame(el)\n    )\n  }\n\n  return false\n}\n\nfunction getFrameElement (el: HTMLElement) {\n  if (!el.ownerDocument || !el.ownerDocument.defaultView) {\n    return null\n  }\n\n  try {\n    return el.ownerDocument.defaultView.frameElement\n  } catch (e) {\n    return null\n  }\n}\n\nfunction isHiddenByFrame (el: HTMLElement): boolean {\n  let frame = getFrameElement(el)\n  if (!frame) {\n    return false\n  }\n\n  return (\n    frame.clientHeight < el.scrollHeight || frame.clientWidth < el.scrollWidth\n  )\n}\n\nfunction alignNearest (\n  scrollingEdgeStart: number,\n  scrollingEdgeEnd: number,\n  scrollingSize: number,\n  scrollingBorderStart: number,\n  scrollingBorderEnd: number,\n  elementEdgeStart: number,\n  elementEdgeEnd: number,\n  elementSize: number\n) {\n  if (\n    (elementEdgeStart < scrollingEdgeStart &&\n      elementEdgeEnd > scrollingEdgeEnd) ||\n    (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)\n  ) {\n    return 0\n  }\n\n  if (\n    (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n    (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)\n  ) {\n    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart\n  }\n\n  if (\n    (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n    (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)\n  ) {\n    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd\n  }\n\n  return 0\n}\n","// @flow\n'use strict'\n\nimport CharacterRange from './characterRange';\nimport Refills from '../refills';\nimport rangeUtils from '../range-utils';\nimport { compute } from './compute';\nimport type { Options } from './compute';\n\ntype StandardBehaviorOptions = {|\n  ...Options;\n  behavior?: 'auto' | 'smooth';\n|}\nexport default class Highlight {\n  characterRange: CharacterRange;\n  refills: Refills;\n  applied: boolean = false;\n  range: Range;\n  constructor (characterRange: CharacterRange, refills: Refills) {\n    this.characterRange = characterRange;\n    this.refills = refills;\n  }\n\n  on (): void {\n    this.range = this.characterRange.toRange();\n    this.refills.appliesToRange(this.range);\n    this.applied = true;\n  }\n\n  off (): void {\n    this.range = this.characterRange.toRange();\n    this.refills.wipeToRange(this.range);\n    this.applied = false;\n  }\n\n  intersectsNode (node: Node): boolean {\n    const range = document.createRange();\n    range.selectNodeContents(node);\n\n    return rangeUtils.intersectsRange(this.characterRange.toRange(), range);\n  }\n\n  scrollIntoView (options?: StandardBehaviorOptions | boolean): void {\n    let behavior = typeof options === 'boolean' ? undefined : options?.behavior\n    compute(this.characterRange.toRange(), getOptions(options)).forEach(({ el, top, left }) => {\n      el.scrollTo({ top, left, behavior: behavior });\n    });\n  }\n\n  getText (): string {\n    return this.toRange().toString();\n  }\n\n  toRange (): Range {\n    return this.characterRange.toRange();\n  }\n}\n\nfunction getOptions (options?: any): Options {\n  if (options === false) {\n    return { block: 'end', inline: 'nearest' }\n  }\n\n  // $FlowIgnore\n  if (options === Object(options) && Object.keys(options).length !== 0) {\n    // $FlowIgnore\n    return options;\n  }\n\n  return { block: 'start', inline: 'nearest' }\n}\n","// @flow\nimport TextSearch from './TextSearch';\nimport { CharacterRange, Refills } from '../../src';\nimport Highlight from '../../src/utils/highlight';\n\nconst textSearch = new TextSearch(),\n  refillsYellow = new Refills({ className: 'yellow' }),\n  refillsOrange = new Refills({ className: 'orange' });\n\nfunction getCharacterRanges (text: string, referenceNode: Element): CharacterRange[] {\n  textSearch.setup(text);\n  return textSearch.find(referenceNode.textContent).filter(pos => pos.string === text).map(pos => {\n    return new CharacterRange(pos.start, pos.end, referenceNode);\n  });\n}\n\nfunction* generator (text: string, referenceNode: Element): any {\n  let count = 0, results = getCharacterRanges(text, referenceNode);\n  while (results.length) {\n    yield results[count++];\n    if (count === results.length) {\n      count = 0;\n    }\n  }\n}\n\nlet characterRangeStore, highlights = [], next = null;\nconst el = document.querySelector('#search'),\n  referenceNode = document.body;\n\nel?.addEventListener('input', debounce(function (e) {\n  let highlight;\n  while ((highlight = highlights.pop())) {\n    highlight.off();\n  }\n\n  if (next) {\n    next.off();\n    next = null;\n  }\n\n  const value = e.target.value;\n  if (value) {\n    // $FlowIgnore\n    characterRangeStore = generator(value, referenceNode);\n    // $FlowIgnore\n    const results = getCharacterRanges(value, referenceNode);\n    results.forEach((cr, indxex) => {\n      highlight = new Highlight(cr, refillsYellow);\n      highlights.push(highlight);\n      highlight.on();\n      if (indxex === 0) {\n        highlight.scrollIntoView({ scrollMode: 'if-needed', block: 'center' });\n      }\n    });\n  }\n\n}, 200));\n\nel?.addEventListener('keyup', debounce(function (e) {\n  if (e.keyCode === 13) {\n    if (next) {\n      next.off();\n    }\n\n    const value = e.target.value;\n    if (value) {\n      next = new Highlight(characterRangeStore.next().value, refillsOrange);\n      next.on();\n      // $FlowIgnore\n      next.scrollIntoView({ scrollMode: 'if-needed', block: 'center' })\n    }\n  }\n}, 100));\n\nfunction debounce (func: Function, wait?: number = 100) {\n  let timestamp, args, timeout, context;\n  function later () {\n    const last = Date.now() - timestamp;\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      func.apply(context, args);\n      context = args = null;\n    }\n\n  }\n  // $FlowIgnore\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    if (!timeout) {\n      timeout = setTimeout(later, wait);\n    }\n  }\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","Position","start","end","string","this","TextSearch","trie","Trie","words","root","Array","isArray","word","search","addWord","tmpQueue","isRoot","length","setQueue","node","children","pre","push","shift","str","result","results","split","entries","i","char","_findNodeOfChar","_getPosition","pos","isEnd","substring","TrieNode","next","current","containsWords","hierarchy","piece","unshift","j","keys","hasOwn","isCharacterDataNode","t","nodeType","Node","TEXT_NODE","COMMENT_NODE","getNodeIndex","index","previousSibling","splitNode","ancestor","descendant","descendantOffset","newNode","offset","splitAtStart","data","parentNode","nextSibling","childNodes","cloneNode","hasAttribute","removeAttribute","child","newIndex","moveNode","newNodeIndex","removeNode","p","removeChild","appendChild","insertBefore","classListSupport","document","createElement","classList","classNameSupport","className","rnothtmlwhite","stripAndCollapse","match","join","classesToArray","toggleClass","el","classNames","ELEMENT_NODE","forEach","toggle","hasClass","removeClass","addClass","getClass","getAttribute","contains","indexOf","curClass","cur","final","add","setAttribute","isElement","arguments","remove","replace","findClosestAncestor","isAncestorOf","selfIsAncestor","n","isOrIsAncestorOf","findSelfOrAncestorWithClass","getNodeLength","crudNode","classes","getSelection","setRange","range","ec","eo","sc","so","len","setStart","setEnd","getIntersectionRange","rangeA","rangeB","intersectsRange","cloneRange","compareBoundaryPoints","START_TO_START","startContainer","startOffset","END_TO_END","endContainer","endOffset","END_TO_START","START_TO_END","RangeIterator","clonePartiallySelectedTextNodes","collapsed","commonAncestorContainer","_next","_end","_current","deleteData","createRange","iterateSubtree","it","cb","isPartiallySelectedSubtree","getSubtreeIterator","nit","createNodeIterator","nextNode","getNodes","nodeTypes","filter","regx","nodes","RegExp","test","toString","getEffectiveTextNodes","textNodes","rangeSelectsAnyText","slice","textNode","textNodeRange","selectNodeContents","intersectionRange","sel","Selection","window","getRangesInSelection","selection","ranges","rangeCount","getRangeAt","intersection","rangeIterator","splitRangeBoundaries","startSameEnd","splitText","each","callback","Refills","options","defaultOptions","tagName","elAttrs","elProps","normalize","propName","propValue","createRefillsOptions","rangeUtils","domUtils","appliesToTextNode","lastTextNode","ancestorWithClass","splitBoundariesAncestorWithClass","wipeToAncestor","isEqualNode","firstChild","attrs","attrName","attrValue","mapAttrs","props","mapProps","isUndo","firstNode","lastNode","currentMerge","merges","rangeStartNode","rangeEndNode","rangeStartOffset","rangeEndOffset","precedingNode","getPrecedingMrTextNode","Merge","getLength","getNextMrTextNode","merge","getter","forward","adjacentPropName","position","checkParentElement","adjacentNode","adjacentNodeChild","firstTextNode","textParts","hasChildNodes","Function","apply","CharacterRange","referenceNode","isCollapsed","wrapRange","characterRanges","fromRange","characterRange","toRange","another","_createRelativeCharacterRange","isIntersects","isAdjoin","Math","min","max","collapse","nextCharIndex","nodeIterator","NodeFilter","SHOW_TEXT","charIndex","foundStart","foundEnd","canOverflow","overflow","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","style","getComputedStyle","overflowY","overflowX","frame","ownerDocument","defaultView","frameElement","e","getFrameElement","isHiddenByFrame","alignNearest","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","scrollingBorderStart","scrollingBorderEnd","elementEdgeStart","elementEdgeEnd","elementSize","Highlight","refills","appliesToRange","applied","wipeToRange","behavior","undefined","target","block","inline","scrollMode","scrollingElement","documentElement","frames","cursor","body","parentElement","viewportWidth","visualViewport","width","innerWidth","viewportHeight","height","innerHeight","scrollX","scrollY","getBoundingClientRect","targetHeight","targetWidth","targetTop","top","targetRight","right","targetBottom","bottom","targetLeft","left","targetBlock","targetInline","computations","frameStyle","borderLeft","parseInt","borderLeftWidth","borderTop","borderTopWidth","borderRight","borderRightWidth","borderBottom","borderBottomWidth","blockScroll","inlineScroll","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","scaleX","scaleY","scrollLeft","scrollTop","compute","getOptions","scrollTo","generator","textSearch","refillsYellow","refillsOrange","getCharacterRanges","text","setup","find","textContent","map","count","characterRangeStore","highlights","querySelector","debounce","func","timestamp","args","timeout","context","wait","later","last","Date","now","setTimeout","addEventListener","highlight","pop","off","cr","indxex","on","scrollIntoView","keyCode"],"sourceRoot":""}