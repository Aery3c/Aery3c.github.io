{"version":3,"file":"serialize.js","mappings":"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","sources":["webpack://highlighter/webpack/bootstrap","webpack://highlighter/webpack/runtime/define property getters","webpack://highlighter/webpack/runtime/hasOwnProperty shorthand","webpack://highlighter/webpack/runtime/make namespace object","webpack://highlighter/./src/utils/eventEmitter.js","webpack://highlighter/./src/dom-utils/isCharacterDataNode.js","webpack://highlighter/./src/dom-utils/getNodeIndex.js","webpack://highlighter/./src/dom-utils/crudNode.js","webpack://highlighter/./src/dom-utils/classes.js","webpack://highlighter/./src/dom-utils/findClosestAncestor.js","webpack://highlighter/./src/dom-utils/getNodeLength.js","webpack://highlighter/./src/dom-utils/index.js","webpack://highlighter/./src/range-utils/setRange.js","webpack://highlighter/./src/range-utils/intersection.js","webpack://highlighter/./src/range-utils/rangeIterator.js","webpack://highlighter/./src/range-utils/getNodes.js","webpack://highlighter/./src/range-utils/selection.js","webpack://highlighter/./src/range-utils/index.js","webpack://highlighter/./src/range-utils/splitRangeBoundaries.js","webpack://highlighter/./src/utils/each.js","webpack://highlighter/./src/utils/createOptions.js","webpack://highlighter/./src/refills.js","webpack://highlighter/./src/utils/characterRange.js","webpack://highlighter/./src/utils/compute.js","webpack://highlighter/./src/utils/highlight.js","webpack://highlighter/./examples/serialize/serialize.js","webpack://highlighter/./src/highlighter.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// @flow\n/* global $Values */\n'use strict'\n\ntype Listener = (...args: Array<any>) => void;\ntype ListenerMap = { [key: string]: Listener };\nconst apply = Function.prototype.apply, call = Function.prototype.call;\nexport default class EventEmitter<U: ListenerMap> {\n  __events__: Object;\n  constructor() {\n    this.__events__ = {};\n  }\n\n  on<T: string> (type: T, listener: $Values<U>): EventEmitter<U> {\n    const data = this.__events__;\n    if (!data[type]) data[type] = listener;\n    else if (typeof data[type] === 'object') data[type].push(listener);\n    else data[type] = [data[type], listener];\n\n    return this;\n  }\n\n  once<T: string> (type: T, listener: $Values<U>): EventEmitter<U> {\n    let once, self;\n\n    self = this;\n    // $FlowIgnore\n    self.on.call(self, type, once = function () {\n      // $FlowIgnore\n      self.off.call(self, type, once);\n      apply.call(listener, self, arguments);\n    });\n    // $FlowIgnore\n    once.__onceListener__ = listener;\n    return this;\n  }\n\n  off<T: string> (type: T, listener: $Values<U>): EventEmitter<U> {\n    const data = this.__events__;\n    if (!data[type]) return this;\n\n    const listeners = data[type];\n\n    if (typeof listeners === 'object') {\n      for (let i = 0, candidate; (candidate = listeners[i]); ++i) {\n        if ((candidate === listener) ||\n          (candidate.__onceListener__ === listener)) {\n          if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n          else listeners.splice(i, 1);\n        }\n      }\n    } else {\n      if ((listeners === listener) ||\n        (listeners.__onceListener__ === listener)) {\n        delete data[type];\n      }\n    }\n\n    return this;\n  }\n\n  emit<T: string> (type: T, ...args: Array<any>): void {\n    let listeners = this.__events__[type];\n    if (!listeners) return;\n\n    let l, i;\n\n    if (typeof listeners === 'object') {\n      l = arguments.length;\n      args = new Array(l - 1);\n      for (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n      listeners = listeners.slice();\n      for (let i = 0, listener; (listener = listeners[i]); ++i) {\n        apply.call(listener, this, args);\n      }\n    } else {\n      switch (arguments.length) {\n        case 1:\n          call.call(listeners, this);\n          break;\n        case 2:\n          call.call(listeners, this, arguments[1]);\n          break;\n        case 3:\n          call.call(listeners, this, arguments[1], arguments[2]);\n          break;\n        default:\n          l = arguments.length;\n          args = new Array(l - 1);\n          for (i = 1; i < l; ++i) {\n            args[i - 1] = arguments[i];\n          }\n          apply.call(listeners, this, args);\n      }\n    }\n  }\n}","// @flow\n'use strict'\n\nexport function isCharacterDataNode (node: Node | null): boolean {\n  if (!node) return false;\n  const t = node.nodeType;\n  return t === Node.TEXT_NODE || t === Node.COMMENT_NODE;\n}","// @flow\n'use strict'\n\nexport function getNodeIndex (node: Node): number {\n  let index = 0;\n  // $FlowIgnore\n  while ((node = node.previousSibling)) {\n    index++;\n  }\n\n  return index;\n}","// @flow\n'use strict'\nimport { isCharacterDataNode } from './isCharacterDataNode';\nimport { getNodeIndex } from './getNodeIndex';\n\nexport function splitNode (ancestor: any, descendant: any, descendantOffset: any): void {\n\n  let newNode, splitAtStart = (descendantOffset === 0);\n\n  if (isCharacterDataNode(descendant)) {\n    let index = getNodeIndex(descendant);\n\n    if (descendantOffset === 0) {\n      descendantOffset = index;\n\n    } else if (descendantOffset === descendant.data.length) {\n      descendantOffset = index + 1;\n    }\n    descendant = descendant.parentNode;\n  }\n\n  if (isSplitPoint(descendant, descendantOffset)) {\n    // clone empty node\n    newNode = descendant.cloneNode(false);\n    if (newNode.hasAttribute('id')) {\n      newNode.removeAttribute('id');\n    }\n    let child, newIndex = 0;\n    while ((child = descendant.childNodes[descendantOffset])) {\n      // move child to newNode\n      moveNode(child, newNode, newIndex++);\n    }\n    // move newNode to parentNode\n    moveNode(newNode, descendant.parentNode, getNodeIndex(descendant) + 1);\n  } else if (ancestor !== descendant) {\n    newNode = descendant.parentNode;\n\n    // Work out a new split point in the parent node\n    let newNodeIndex = getNodeIndex(descendant);\n\n    if (!splitAtStart) {\n      newNodeIndex++;\n    }\n    return splitNode(ancestor, newNode, newNodeIndex);\n  }\n}\n\nfunction isSplitPoint(node: Node, offset: number): boolean {\n  // Node.TEXT_NODE\n  if (isCharacterDataNode(node)) {\n    if (offset === 0) {\n      return !!node.previousSibling;\n      // $FlowIgnore\n    } else if (offset === node.length) {\n      return !!node.nextSibling;\n    } else {\n      return true;\n    }\n  }\n\n  // Node.ELEMENT_NODE\n  return offset > 0 && offset < node.childNodes.length;\n}\nexport function removeNode (node: Node): Node | null {\n  const p = node.parentNode;\n  if (p) {\n    return p.removeChild(node);\n  }\n\n  return null;\n}\n\nexport function moveNode (node: Node, newNode: Node, newIndex: number): void {\n  if (newIndex === -1) {\n    newIndex = newNode.childNodes.length;\n  }\n\n  if (newIndex === newNode.childNodes.length) {\n    newNode.appendChild(node);\n  } else {\n    newNode.insertBefore(node, newNode.childNodes[newIndex]);\n  }\n}","// @flow\n'use strict'\n\nconst classListSupport = !(typeof document.createElement('span').classList !== 'undefined');\nconst classNameSupport = !(typeof document.createElement('span').className !== 'undefined');\n\n// $FlowIgnore\nexport const rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\nexport function stripAndCollapse (value: string): string {\n  const tokens = value.match(rnothtmlwhite) || [];\n  return tokens.join(' ');\n}\n\n/**\n *\n * @param {string|Array} value\n * @return {string[]}\n */\nexport function classesToArray (value: string | Array<string>): string[] {\n  if (Array.isArray(value)) {\n    return value;\n  }\n  if (typeof value === 'string') {\n    return value.match(rnothtmlwhite) || [];\n  }\n  return [];\n}\n\n/**\n *\n * @param {HTMLElement} el\n * @param {string} value\n */\nexport function toggleClass (el: HTMLElement, value: string): boolean {\n  const classNames = classesToArray(value);\n\n  if (classNames.length && el.nodeType === Node.ELEMENT_NODE) {\n    classNames.forEach(className => {\n      if (classListSupport) {\n        el.classList.toggle(className);\n      } else {\n        if (hasClass(el, className)) {\n          removeClass(el, className);\n        } else {\n          addClass(el, className);\n        }\n      }\n    });\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n *\n * @param {HTMLElement} el\n * @return {string}\n */\nexport function getClass (el: HTMLElement): string {\n\n  if (el.nodeType !== Node.ELEMENT_NODE) {\n    return '';\n  }\n\n  if (classNameSupport) {\n    return el.className;\n  }\n\n  return el.getAttribute('class') || '';\n}\n\n/**\n *\n */\nexport function hasClass (el: HTMLElement, value: string): boolean {\n\n  if (el.nodeType !== Node.ELEMENT_NODE) {\n    return false;\n  }\n\n  if (classListSupport) {\n    return el.classList.contains(value);\n  }\n  const classNames = classesToArray(getClass(el));\n  return classNames.indexOf(value) > -1;\n}\n\n/**\n *\n * @param {HTMLElement | Node} el\n * @param {string} value\n */\nexport function addClass (el: HTMLElement, value: string): void {\n\n  let classNames = classesToArray(value), curClass, cur, final;\n\n  if (classNames.length && el.nodeType === Node.ELEMENT_NODE) {\n    if (classListSupport) {\n      el.classList.add(...classNames);\n    } else {\n      curClass = getClass(el);\n      cur = ' ' + stripAndCollapse(curClass) + ' ';\n      classNames.forEach(className => {\n        if (cur.indexOf(' ' + className + ' ') < 0) {\n          cur += className + ' '\n        }\n      });\n\n      final = stripAndCollapse(cur);\n\n      if (curClass !== final) {\n        if (classNameSupport) {\n          el.className = final;\n        } else {\n          el.setAttribute('class', final);\n        }\n      }\n    }\n  }\n}\n\n/**\n *\n * @param {HTMLElement | Node} el\n * @param {string} [value]\n */\nexport function removeClass (el: HTMLElement, value: string): void {\n\n  let classNames = classesToArray(value), curClass, cur, final,\n    isElement = (el.nodeType === Node.ELEMENT_NODE);\n\n  if (arguments.length < 2 && isElement) {\n    return el.removeAttribute('class');\n  }\n\n  if (classNames.length && isElement) {\n    if (classListSupport) {\n      el.classList.remove(...classNames);\n    } else {\n      curClass = getClass(el);\n      cur = ' ' + stripAndCollapse(curClass) + ' ';\n      classNames.forEach(className => {\n        while (cur.indexOf(' ' + className + ' ') > -1) {\n          cur = cur.replace(' ' + className + ' ', ' ');\n        }\n      });\n\n      final = stripAndCollapse(cur);\n      if (curClass !== final) {\n        if (classNameSupport) {\n          el.className = final;\n        } else {\n          el.setAttribute('class', final);\n        }\n      }\n    }\n  }\n}\n","// @flow\n'use strict'\n\nimport { hasClass } from './classes';\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} node\n * @return {Node | null}\n */\nexport function findClosestAncestor (ancestor: Node, node: Node): Node | null {\n  let p;\n  while (node) {\n    p = node.parentNode;\n    if (p === ancestor) {\n      return node\n    }\n    // $FlowIgnore\n    node = p;\n  }\n\n  return null;\n}\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} descendant\n * @param {boolean} selfIsAncestor\n */\nexport function isAncestorOf (ancestor: Node, descendant: Node, selfIsAncestor: boolean): boolean {\n  let n = selfIsAncestor ? descendant : descendant.parentNode;\n  while (n) {\n    if (n === ancestor) {\n      return true;\n    } else {\n      n = n.parentNode;\n    }\n  }\n  return false;\n}\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} descendant\n * @return {boolean}\n */\nexport function isOrIsAncestorOf(ancestor: Node, descendant: Node): boolean {\n  return isAncestorOf(ancestor, descendant, true);\n}\n\nexport function findSelfOrAncestorWithClass (node: Node, className: string): Node | null {\n  while (node) {\n    // $FlowIgnore\n    if (hasClass(node, className)) {\n      return node;\n    }\n    // $FlowIgnore\n    node = node.parentNode;\n  }\n  return null;\n}\n\n","// @flow\n'use strict'\n\n/**\n * The element node returns the child node length, and the text node returns the text length\n * @param {Node|Text} node\n */\n\nimport { isCharacterDataNode } from './isCharacterDataNode';\n\nexport function getNodeLength (node: Node): number {\n  const t = node.nodeType;\n  if (t === Node.ELEMENT_NODE) {\n    return node.childNodes.length;\n  } else if (isCharacterDataNode(node)) {\n    // $FlowIgnore\n    return node.length;\n  }\n  return 0;\n}","// @flow\n\nimport * as crudNode from './crudNode';\nimport * as classes from './classes';\nimport * as findClosestAncestor from './findClosestAncestor';\nimport { isCharacterDataNode } from './isCharacterDataNode';\nimport { getNodeIndex } from './getNodeIndex';\nimport { getNodeLength } from './getNodeLength';\n\nexport default {\n  ...crudNode,\n  ...classes,\n  ...findClosestAncestor,\n  isCharacterDataNode,\n  getNodeIndex,\n  getNodeLength,\n  getSelection\n};","// @flow\n'use strict'\nimport { getNodeLength } from '../dom-utils/getNodeLength';\n\nexport function setRange (range: Range, ...args: Array<any>) {\n  let sc = args[0], so = args[1], ec, eo;\n  const len = getNodeLength(sc);\n\n  switch (args.length) {\n    case 2:\n      ec = sc;\n      eo = len;\n      break;\n    case 3:\n      ec = args[2];\n      eo = so;\n      break;\n    case 4:\n      ec = args[2];\n      eo = args[3];\n      break;\n  }\n\n  range.setStart(sc, so);\n  // $FlowIgnore\n  range.setEnd(ec, eo);\n}\n","// @flow\n'use strict'\n\n/**\n * Returns the part of a specified range that intersects another range\n */\nexport function getIntersectionRange (rangeA: Range, rangeB: Range): Range | null {\n  if (intersectsRange(rangeA, rangeB)) {\n    const range = rangeA.cloneRange();\n    // $FlowIgnore\n    if (range.compareBoundaryPoints(rangeB.START_TO_START, rangeB) === -1) {\n      range.setStart(rangeB.startContainer, rangeB.startOffset);\n    }\n    // $FlowIgnore\n    if (range.compareBoundaryPoints(rangeB.END_TO_END, rangeB) === 1) {\n      range.setEnd(rangeB.endContainer, rangeB.endOffset);\n    }\n\n    return range;\n  }\n\n  return null;\n}\n\n/**\n * Returns a boolean indicating whether the given Range intersects the Range.\n */\nexport function intersectsRange (rangeA: Range, rangeB: Range): boolean {\n  // rangeA.s < rangeB.e;\n  // $FlowIgnore\n  const start = rangeA.compareBoundaryPoints(rangeB.END_TO_START, rangeB);\n  // rangeA.e > rangeB.s;\n  // $FlowIgnore\n  const end = rangeA.compareBoundaryPoints(rangeB.START_TO_END, rangeB);\n\n  return start < 0 && end > 0;\n}","// @flow\n'use strict'\n\nimport { isCharacterDataNode } from '../dom-utils/isCharacterDataNode';\nimport { findClosestAncestor, isOrIsAncestorOf } from '../dom-utils/findClosestAncestor';\nimport { getNodeLength } from '../dom-utils/getNodeLength';\nimport { setRange } from './setRange';\n\nexport class RangeIterator {\n  range: Range;\n  clonePartiallySelectedTextNodes: boolean;\n  root: Node;\n  sc: Node;\n  so: number;\n  ec: Node;\n  eo: number;\n  _current: Node | null = null;\n  _end: Node | null = null;\n  _next: Node | null = null;\n  constructor(range: Range, clonePartiallySelectedTextNodes?: boolean = false) {\n    this.range = range;\n    this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n    if (!this.range.collapsed) {\n      this.root = this.range.commonAncestorContainer;\n      this.sc = this.range.startContainer;\n      this.so = this.range.startOffset;\n      this.ec = this.range.endContainer;\n      this.eo = this.range.endOffset;\n\n      if (this.sc === this.ec && isCharacterDataNode(this.sc)) {\n        this._next = this._end = this.sc;\n      } else {\n        this._next = this.sc === this.root && !isCharacterDataNode(this.sc)\n          ? this.sc.childNodes[this.so] : findClosestAncestor(this.root, this.sc)\n\n        this._end = this.ec === this.root && !isCharacterDataNode(this.ec)\n          ? this.ec.childNodes[this.eo - 1] : findClosestAncestor(this.root, this.ec);\n      }\n    }\n\n  }\n  next (): Node | null {\n    let current = this._current = this._next;\n    // $FlowIgnore\n    this._next = this._current != null && this._current !== this._end ? this._current.nextSibling : null;\n\n    // Check for partially selected text nodes\n    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n      // clone partially selected text nodes\n      // return cloneNode\n      if (current === this.ec) {\n        // $FlowIgnore\n        (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n      }\n\n      if (current === this.sc) {\n        // $FlowIgnore\n        (current = current.cloneNode(true)).deleteData(0, this.so);\n      }\n    }\n\n    return current;\n  }\n\n  isPartiallySelectedSubtree (): boolean {\n    return !isCharacterDataNode(this._current) &&\n      // $FlowIgnore\n      (isOrIsAncestorOf(this._current, this.sc) || isOrIsAncestorOf(this._current, this.ec));\n  }\n\n  getSubtreeIterator (): RangeIterator {\n    const range = document.createRange(), current = this._current;\n    // $FlowIgnore\n    let startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);\n\n    if (current) {\n      if (isOrIsAncestorOf(current, this.sc)) {\n        startContainer = this.sc;\n        startOffset = this.so;\n      }\n      if (isOrIsAncestorOf(current, this.ec)) {\n        endContainer = this.ec;\n        endOffset = this.eo;\n      }\n    }\n\n    setRange(range, startContainer, startOffset, endContainer, endOffset);\n\n    return new RangeIterator(range, this.clonePartiallySelectedTextNodes);\n  }\n}\n\nexport function iterateSubtree (it: RangeIterator, cb: (node: Node) => void) {\n  let node;\n  while((node = it.next())) {\n    if (it.isPartiallySelectedSubtree()) {\n      const subIt = it.getSubtreeIterator();\n      iterateSubtree(subIt, cb);\n    } else {\n      const nit = document.createNodeIterator(node);\n      while((node = nit.nextNode())) {\n        cb(node);\n      }\n    }\n  }\n}","// @flow\n'use strict'\n\nimport { RangeIterator, iterateSubtree } from './rangeIterator';\nimport { getIntersectionRange } from './intersection';\n\nexport function getNodes (range: Range, nodeTypes?: Array<number>, filter?: (node: Node) => boolean): Node[] {\n  let nodes = [], regx;\n  if (nodeTypes && nodeTypes.length) {\n    regx = new RegExp(`(${nodeTypes.join('|')})$`);\n  }\n\n  iterateSubtree(new RangeIterator(range, false), (node) => {\n    if (regx && !regx.test(node.nodeType.toString())) {\n      return;\n    }\n\n    if (typeof filter == 'function' && !filter(node)) {\n      return;\n    }\n\n    nodes.push(node);\n  });\n\n  return nodes;\n}\n\n/**\n * range (prev/next) point (last/first)\n * @param range\n */\nexport function getEffectiveTextNodes (range: Range): Node[] {\n  const textNodes = getNodes(range, [Node.TEXT_NODE]);\n\n  let start = 0, end = textNodes.length, node;\n\n  // remove invalid text nodes from left to right\n  while ((node = textNodes[start]) && !rangeSelectsAnyText(range, node)) {\n    ++start;\n  }\n\n  // remove invalid text nodes from right to left\n  while ((node = textNodes[end - 1]) && !rangeSelectsAnyText(range, node)) {\n    --end;\n  }\n\n  return textNodes.slice(start, end);\n}\n\n\nfunction rangeSelectsAnyText(range: Range, textNode: Node): boolean {\n  const textNodeRange = document.createRange();\n  textNodeRange.selectNodeContents(textNode);\n  const intersectionRange = getIntersectionRange(textNodeRange, range);\n  const text = intersectionRange ? intersectionRange.toString() : '';\n  return text !== '';\n}\n","// @flow\n'use strict'\n\nexport function getSelection (sel?: any): Selection {\n  if (sel instanceof Selection) {\n    return sel;\n  }\n\n  return window.getSelection();\n}\n\nexport function getRangesInSelection (selection: Selection): Range[] {\n  const ranges = [];\n  for (let i = 0; i < selection.rangeCount; ++i) {\n    ranges.push(selection.getRangeAt(i));\n  }\n\n  return ranges;\n}","// @flow\n'use strict'\nimport { setRange } from './setRange';\nimport * as intersection from './intersection';\nimport * as getNodes from './getNodes';\nimport * as rangeIterator from './rangeIterator';\nimport { splitRangeBoundaries } from './splitRangeBoundaries';\nimport * as selection from './selection';\n\nexport default {\n  ...intersection,\n  ...getNodes,\n  ...rangeIterator,\n  ...selection,\n  splitRangeBoundaries,\n  setRange\n}","// @flow\n'use strict'\n\nimport { isCharacterDataNode } from '../dom-utils/isCharacterDataNode';\nimport { getNodeIndex } from '../dom-utils/getNodeIndex';\n\nexport function splitRangeBoundaries (range: Range): void {\n  let [sc, so, ec, eo] = [range.startContainer, range.startOffset, range.endContainer, range.endOffset];\n  const startSameEnd: boolean = (sc === ec);\n  // $FlowIgnore\n  if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n    // $FlowIgnore\n    ec.splitText(eo);\n  }\n  // $FlowIgnore\n  if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n    // $FlowIgnore\n    sc = sc.splitText(so);\n    if (startSameEnd) {\n      eo -= so;\n      ec = sc;\n    } else if (ec === sc.parentNode && eo <= getNodeIndex(sc)) {\n      eo++;\n    }\n    so = 0;\n  }\n}","// @flow\n'use strict'\n\nimport type { Obj } from '../types';\nexport function each (obj: Obj, callback: (propName: any, propValue: any) => boolean | void): Obj {\n  for (let i in obj) {\n    if (callback.call(obj[i], i, obj[i]) === false) {\n      break;\n    }\n  }\n\n  return obj;\n}","// @flow\n\n'use strict'\nimport type { RefillsOptions, DefaultRefillsOptions } from '../types';\n\nimport { each } from './each';\nexport function createRefillsOptions (options?: RefillsOptions = {}): DefaultRefillsOptions {\n  const defaultOptions = {\n    tagName: 'span',\n    className: 'highlight',\n    elAttrs: {},\n    elProps: {},\n    normalize: true\n  }\n\n  each(options, (propName, propValue) => {\n    // eslint-disable-next-line no-prototype-builtins\n    if (options.hasOwnProperty(propName)) {\n      defaultOptions[propName] = propValue;\n    }\n  });\n\n  return defaultOptions;\n}\n\n","// @flow\n'use strict'\n\nimport type { RefillsOptions, DefaultRefillsOptions } from './types';\nimport domUtils from './dom-utils';\nimport rangeUtils from './range-utils';\nimport { createRefillsOptions } from './utils/createOptions';\nimport { each } from './utils/each';\n\nexport default class Refills {\n  options: DefaultRefillsOptions;\n  constructor(options?: RefillsOptions) {\n    this.options = createRefillsOptions(options);\n  }\n\n  appliesToRange (range: Range): void {\n    rangeUtils.splitRangeBoundaries(range);\n\n    const textNodes = rangeUtils.getEffectiveTextNodes(range);\n    if (textNodes.length) {\n      textNodes.forEach(textNode => {\n        if (this.options.className && !domUtils.findSelfOrAncestorWithClass(textNode, this.options.className)) {\n          this.appliesToTextNode(textNode);\n        }\n      });\n\n      const lastTextNode = textNodes[textNodes.length - 1];\n      // $FlowIgnore\n      rangeUtils.setRange(range, textNodes[0], 0, lastTextNode, lastTextNode.length);\n      if (this.options.normalize) {\n        this.normalize(textNodes, range, false);\n      }\n    }\n  }\n\n  appliesToTextNode (textNode: Node): void {\n    const parentNode = textNode.parentNode;\n    if (textNode.nodeType === Node.TEXT_NODE && parentNode) {\n      const el = this.createElement();\n      if (el) {\n        parentNode.insertBefore(el, textNode);\n        el.appendChild(textNode);\n      }\n    }\n  }\n\n  wipeToRange (range: Range): void {\n    rangeUtils.splitRangeBoundaries(range);\n\n    const textNodes = rangeUtils.getEffectiveTextNodes(range);\n\n    if (textNodes.length) {\n      // split boundaries ancestor with class\n      splitBoundariesAncestorWithClass(range, this.options.className);\n      textNodes.forEach(textNode => {\n        let ancestorWithClass = domUtils.findSelfOrAncestorWithClass(textNode, this.options.className);\n        if (ancestorWithClass) {\n          this.wipeToAncestor(ancestorWithClass);\n        }\n      });\n\n      const lastTextNode = textNodes[textNodes.length - 1];\n      // $FlowIgnore\n      rangeUtils.setRange(range, textNodes[0], 0, lastTextNode, lastTextNode.length);\n      if (this.options.normalize) {\n        this.normalize(textNodes, range, true);\n      }\n    }\n  }\n\n  wipeToAncestor (ancestor: any): void {\n    if (this.isEqualNode(ancestor)) {\n      let child, index = domUtils.getNodeIndex(ancestor);\n      const parentNode = ancestor.parentNode;\n\n      while ((child = ancestor.firstChild)) {\n        // move children to sibling\n        domUtils.moveNode(child, parentNode, index++);\n      }\n\n      domUtils.removeNode(ancestor);\n    } else {\n      domUtils.removeClass(ancestor, this.options.className);\n    }\n  }\n\n  createElement (): HTMLElement | null {\n    if (this.options.tagName) {\n      const el = document.createElement(this.options.tagName);\n      if (this.options.className && this.options.elAttrs && this.options.elProps) {\n        domUtils.addClass(el, this.options.className);\n        // $FlowIgnore\n        mapAttrs(el, this.options.elAttrs);\n        // $FlowIgnore\n        mapProps(el, this.options.elProps);\n      }\n      return el;\n    }\n\n    return null;\n  }\n\n  normalize (textNodes: Node[], range: Range, isUndo: boolean): void {\n    let firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];\n\n    let currentMerge = null, merges = [];\n\n    let rangeStartNode = firstNode, rangeEndNode = lastNode;\n    // $FlowIgnore\n    let rangeStartOffset = 0, rangeEndOffset = lastNode.length;\n\n    textNodes.forEach(textNode => {\n      // go through each textNode and find the mergable node in front of them,\n      const precedingNode = getPrecedingMrTextNode(textNode, !isUndo, (node) => {\n        return this.isEqualNode(node);\n      });\n\n      if (precedingNode) {\n        // create a Merge object headed by precedingNode\n        if (currentMerge == null) {\n          currentMerge = new Merge(precedingNode);\n          merges.push(currentMerge);\n        }\n        // $FlowIgnore\n        currentMerge.textNodes.push(textNode);\n\n        if (rangeStartNode === textNode) {\n          // $FlowIgnore\n          rangeStartNode = currentMerge.textNodes[0];\n          // $FlowIgnore\n          rangeStartOffset = rangeStartNode.length;\n        }\n\n        if (rangeEndNode === textNode) {\n          // $FlowIgnore\n          rangeEndNode = currentMerge.textNodes[0];\n          // $FlowIgnore\n          rangeEndOffset = currentMerge.getLength();\n        }\n\n      } else {\n        // reset the current Merge object to create a new merge\n        currentMerge = null;\n      }\n    });\n\n    const nextNode = getNextMrTextNode(lastNode, !isUndo, (node) => {\n      return this.isEqualNode(node);\n    });\n\n    if (nextNode) {\n      if (currentMerge == null) {\n        currentMerge = new Merge(lastNode);\n        merges.push(currentMerge);\n      }\n      // $FlowIgnore\n      currentMerge.textNodes.push(nextNode);\n    }\n\n    if (merges.length) {\n      merges.forEach(merge => merge.start());\n\n      rangeUtils.setRange(range, rangeStartNode, rangeStartOffset, rangeEndNode, rangeEndOffset);\n    }\n  }\n\n  isEqualNode (node: Node): boolean {\n    const newNode = this.createElement();\n    if (newNode) {\n      return newNode.cloneNode(false).isEqualNode(node.cloneNode(false));\n    }\n    return false;\n  }\n}\n\nfunction mapAttrs (el: HTMLElement, attrs: Object) {\n  each(attrs, function (attrName, attrValue) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (attrs.hasOwnProperty(attrName) && !/^class(?:Name)?$/i.test(attrName)) {\n      el.setAttribute(attrName, attrValue);\n    }\n  });\n}\n\nfunction mapProps (el: HTMLElement, props: Object) {\n  each(props, function (propName, propValue) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (props.hasOwnProperty(propName)) {\n      if (propName === 'className') {\n        domUtils.addClass(el, propValue);\n      } else {\n        // $FlowIgnore\n        el[propName] = propValue;\n      }\n    }\n  });\n}\n\nconst getPrecedingMrTextNode = getter(false);\n\nconst getNextMrTextNode = getter(true);\nfunction getter (forward: boolean): ((textNode: Node, checkParentElement: boolean, filter?: (node: Node) => boolean) => Node | null) {\n  const adjacentPropName = forward ? 'nextSibling' : 'previousSibling';\n  const position = forward ? 'firstChild' : 'lastChild';\n  return function (textNode, checkParentElement, filter) {\n    // $FlowIgnore\n    let adjacentNode = textNode[adjacentPropName], parentNode = textNode.parentNode;\n\n    if (adjacentNode && adjacentNode.nodeType === Node.TEXT_NODE) {\n      return adjacentNode\n    } else if (checkParentElement) {\n      // $FlowIgnore\n      adjacentNode = parentNode[adjacentPropName];\n      if (adjacentNode && adjacentNode.nodeType === Node.ELEMENT_NODE) {\n        if (filter && !filter(adjacentNode)) {\n          return null;\n        }\n        let adjacentNodeChild = adjacentNode[position];\n        if (adjacentNodeChild && adjacentNodeChild.nodeType === Node.TEXT_NODE) {\n          return adjacentNodeChild\n        }\n      }\n    }\n\n    return null\n  }\n}\n\nfunction splitBoundariesAncestorWithClass (range: Range, className: string): void {\n  [{ node: range.endContainer, offset: range.endOffset }, { node: range.startContainer, offset: range.startOffset }]\n    .forEach(({ node, offset }) => {\n      const ancestorWithClass = domUtils.findSelfOrAncestorWithClass(node, className);\n      if (ancestorWithClass) {\n        domUtils.splitNode(ancestorWithClass, node, offset);\n      }\n    });\n}\n\nclass Merge {\n  firstTextNode: Node;\n  textNodes: Node[];\n  constructor(node: Node) {\n    const n = node.nodeType === Node.ELEMENT_NODE ? node.firstChild : node;\n    if (n) {\n      this.firstTextNode = n;\n      this.textNodes = [n];\n    }\n  }\n\n  start (): string {\n    const textParts = [];\n    this.textNodes.forEach((textNode, index) => {\n      const parentNode = textNode.parentNode;\n      if (index > 0 && parentNode) {\n        domUtils.removeNode(textNode);\n        if (!parentNode.hasChildNodes()) {\n          domUtils.removeNode(parentNode);\n        }\n      }\n      // $FlowIgnore\n      textParts.push(textNode.data);\n    });\n    // $FlowIgnore\n    this.firstTextNode.data = textParts.join('');\n    return this.firstTextNode.data;\n  }\n\n  getLength (): number {\n    let len = 0;\n    this.textNodes.forEach(textNode => {\n      // $FlowIgnore\n      len += textNode.length;\n    });\n    return len;\n  }\n}","// @flow\n'use strict'\nimport rangeUtils from '../range-utils';\n\nexport default class CharacterRange {\n\n  start: number;\n  end: number;\n  referenceNode: Node;\n  isCollapsed: boolean;\n  constructor(start: number, end: number, referenceNode: Node) {\n    this.start = start;\n    this.end = end;\n    this.referenceNode = referenceNode;\n    this.isCollapsed = this.start === this.end;\n  }\n\n  _createRelativeCharacterRange (characterRange: CharacterRange): CharacterRange {\n    if (characterRange.referenceNode !== this.referenceNode) {\n      return CharacterRange.fromRange(characterRange.toRange(), this.referenceNode);\n    }\n\n    return characterRange;\n  }\n  isEqual (another: CharacterRange): boolean {\n    another = this._createRelativeCharacterRange(another);\n    return this.start === another.start && this.end === another.end;\n  }\n\n  isIntersects (another: CharacterRange): boolean {\n    another = this._createRelativeCharacterRange(another);\n    return this.start < another.end && this.end > another.start;\n  }\n\n  isAdjoin (another: CharacterRange): boolean {\n    another = this._createRelativeCharacterRange(another);\n    return this.start === another.end || this.end === another.start\n  }\n\n  union (another: CharacterRange): CharacterRange | null {\n    another = this._createRelativeCharacterRange(another);\n    if (this.isIntersects(another) || this.isAdjoin(another)) {\n      return new CharacterRange(Math.min(this.start, another.start), Math.max(this.end, another.end), this.referenceNode);\n    }\n    return null\n  }\n\n  intersection (another: CharacterRange): CharacterRange | null {\n    another = this._createRelativeCharacterRange(another);\n    if (this.isIntersects(another)) {\n      return new CharacterRange(Math.max(this.start, another.start), Math.min(this.end, another.end), this.referenceNode);\n    }\n\n    return null;\n  }\n\n  complementarySet (another: CharacterRange): CharacterRange[] {\n    const characterRanges = [];\n    another = this._createRelativeCharacterRange(another);\n\n    if (this.start < another.start) {\n      characterRanges.push(new CharacterRange(this.start, another.start, this.referenceNode));\n    }\n\n    if (this.end > another.end) {\n      characterRanges.push(new CharacterRange(another.end, this.end, this.referenceNode));\n    }\n\n    return characterRanges;\n  }\n\n  toRange (): Range {\n    const range = document.createRange();\n    const { start, end } = this;\n    range.setStart(this.referenceNode, 0);\n    range.collapse(true);\n\n    const nodeIterator = document.createNodeIterator(this.referenceNode, NodeFilter.SHOW_TEXT);\n    let textNode, charIndex = 0, nextCharIndex;\n\n    let foundStart = false, foundEnd = false;\n    while (!foundEnd && (textNode = nodeIterator.nextNode()) && textNode) {\n      nextCharIndex = charIndex + textNode.length;\n      if (!foundStart && start >= charIndex && start <= nextCharIndex) {\n        range.setStart(textNode, start - charIndex);\n        foundStart = true;\n      }\n\n      if (end >= charIndex && end <= nextCharIndex) {\n        range.setEnd(textNode, end - charIndex);\n        foundEnd = true;\n      }\n      charIndex = nextCharIndex;\n    }\n\n    return range;\n  }\n  static fromRange (range: Range, referenceNode: Node): CharacterRange {\n    const wrapRange = range.cloneRange();\n    wrapRange.selectNodeContents(referenceNode);\n\n    const intersectionRange = rangeUtils.getIntersectionRange(wrapRange, range);\n    let start = 0, end = 0;\n    if (intersectionRange) {\n      wrapRange.setEnd(intersectionRange.startContainer, intersectionRange.startOffset);\n      start = wrapRange.toString().length;\n      end = start + intersectionRange.toString().length\n    }\n\n    return new CharacterRange(start, end, referenceNode);\n\n  }\n  static fromSelection (sel: Selection, referenceNode: HTMLElement | Node): CharacterRange[] {\n    const characterRanges = []\n    rangeUtils.getRangesInSelection(sel).forEach(range => {\n      characterRanges.push(CharacterRange.fromRange(range, referenceNode));\n    });\n\n    return characterRanges;\n  }\n}","// @flow\n'use strict'\n\nexport type Options = {|\n  scrollMode?: 'always' | 'if-needed';\n  block?: 'center' | 'end' | 'nearest' | 'start';\n  inline?: 'center' | 'end' | 'nearest' | 'start';\n|}\n\nexport type ScrollAction = {\n  el: HTMLElement;\n  top: number;\n  left: number;\n}\n\nexport function compute (target: Range, options: Options): ScrollAction[] {\n  const { block, inline, scrollMode } = options;\n  let scrollingElement = document.scrollingElement || document.documentElement;\n\n  let frames: HTMLElement[] = [];\n  let cursor = isElement(target.commonAncestorContainer);\n  while (cursor) {\n    if (cursor === scrollingElement) {\n      frames.push(cursor);\n      break;\n    }\n\n    if (\n      cursor === document.body &&\n      isScrollable(cursor) &&\n      // $FlowIgnore\n      !isScrollable(document.documentElement)\n    ) {\n      continue\n    }\n\n    if (cursor != null && isScrollable(cursor)) {\n      frames.push(cursor)\n    }\n    // $FlowIgnore\n    cursor = cursor.parentElement;\n  }\n  let viewportWidth = window.visualViewport?.width ?? window.innerWidth;\n  let viewportHeight = window.visualViewport?.height ?? window.innerHeight;\n  let { scrollX, scrollY } = window\n\n  let {\n    height: targetHeight,\n    width: targetWidth,\n    top: targetTop,\n    right: targetRight,\n    bottom: targetBottom,\n    left: targetLeft,\n  } = target.getBoundingClientRect();\n\n  let targetBlock: number =\n    block === 'start' || block === 'nearest'\n      ? targetTop\n      : block === 'end'\n        ? targetBottom\n        : targetTop + targetHeight / 2\n\n  let targetInline: number =\n    inline === 'center'\n      ? targetLeft + targetWidth / 2\n      : inline === 'end'\n        ? targetRight\n        : targetLeft\n\n  const computations = [];\n  frames.forEach(frame => {\n    let { height, width, top, right, bottom, left } =\n      frame.getBoundingClientRect()\n\n    if (\n      scrollMode === 'if-needed' &&\n      targetTop >= 0 &&\n      targetLeft >= 0 &&\n      targetBottom <= viewportHeight &&\n      targetRight <= viewportWidth &&\n      targetTop >= top &&\n      targetBottom <= bottom &&\n      targetLeft >= left &&\n      targetRight <= right\n    ) {\n      return computations\n    }\n\n    let frameStyle = getComputedStyle(frame)\n    let borderLeft = parseInt(frameStyle.borderLeftWidth, 10)\n    let borderTop = parseInt(frameStyle.borderTopWidth, 10)\n    let borderRight = parseInt(frameStyle.borderRightWidth, 10)\n    let borderBottom = parseInt(frameStyle.borderBottomWidth, 10)\n\n    let blockScroll: number = 0\n    let inlineScroll: number = 0\n\n    let scrollbarWidth =\n      'offsetWidth' in frame\n        ? frame.offsetWidth -\n        frame.clientWidth -\n        borderLeft -\n        borderRight\n        : 0\n    let scrollbarHeight =\n      'offsetHeight' in frame\n        ? frame.offsetHeight -\n        frame.clientHeight -\n        borderTop -\n        borderBottom\n        : 0\n\n    let scaleX =\n      'offsetWidth' in frame\n        ? frame.offsetWidth === 0\n          ? 0\n          : width / frame.offsetWidth\n        : 0\n    let scaleY =\n      'offsetHeight' in frame\n        ? frame.offsetHeight === 0\n          ? 0\n          : height / frame.offsetHeight\n        : 0\n\n\n    if (scrollingElement === frame) {\n      if (block === 'start') {\n        blockScroll = targetBlock\n      } else if (block === 'end') {\n        blockScroll = targetBlock - viewportHeight\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(\n          scrollY,\n          scrollY + viewportHeight,\n          viewportHeight,\n          borderTop,\n          borderBottom,\n          scrollY + targetBlock,\n          scrollY + targetBlock + targetHeight,\n          targetHeight\n        )\n      } else {\n        blockScroll = targetBlock - viewportHeight / 2\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - viewportWidth / 2\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - viewportWidth\n      } else {\n        inlineScroll = alignNearest(\n          scrollX,\n          scrollX + viewportWidth,\n          viewportWidth,\n          borderLeft,\n          borderRight,\n          scrollX + targetInline,\n          scrollX + targetInline + targetWidth,\n          targetWidth\n        )\n      }\n\n      blockScroll = Math.max(0, blockScroll + scrollY)\n      inlineScroll = Math.max(0, inlineScroll + scrollX)\n    } else {\n      if (block === 'start') {\n        blockScroll = targetBlock - top - borderTop\n      } else if (block === 'end') {\n        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(\n          top,\n          bottom,\n          height,\n          borderTop,\n          borderBottom + scrollbarHeight,\n          targetBlock,\n          targetBlock + targetHeight,\n          targetHeight\n        )\n      } else {\n        blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline - left - borderLeft\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - right + borderRight + scrollbarWidth\n      } else {\n        inlineScroll = alignNearest(\n          left,\n          right,\n          width,\n          borderLeft,\n          borderRight + scrollbarWidth,\n          targetInline,\n          targetInline + targetWidth,\n          targetWidth\n        )\n      }\n\n      let { scrollLeft, scrollTop } = frame\n      blockScroll = Math.max(\n        0,\n        Math.min(\n          scrollTop + blockScroll / scaleY,\n          frame.scrollHeight - height / scaleY + scrollbarHeight\n        )\n      )\n      inlineScroll = Math.max(\n        0,\n        Math.min(\n          scrollLeft + inlineScroll / scaleX,\n          frame.scrollWidth - width / scaleX + scrollbarWidth\n        )\n      )\n      targetBlock += scrollTop - blockScroll\n      targetInline += scrollLeft - inlineScroll\n    }\n\n    computations.push({ el: frame, top: blockScroll, left: inlineScroll })\n  })\n  return computations;\n}\n\nfunction isElement (el: any): HTMLElement | null {\n  if (el && el.nodeType === Node.ELEMENT_NODE) {\n    return el;\n  }\n\n  return null\n}\n\nfunction canOverflow (\n  overflow: string | null,\n) {\n  if (overflow === 'hidden') {\n    return false\n  }\n\n  return overflow !== 'visible' && overflow !== 'clip'\n}\n\nfunction isScrollable (el: HTMLElement): boolean {\n  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {\n    let style = getComputedStyle(el)\n    return (\n      canOverflow(style.overflowY) ||\n      canOverflow(style.overflowX) ||\n      isHiddenByFrame(el)\n    )\n  }\n\n  return false\n}\n\nfunction getFrameElement (el: HTMLElement) {\n  if (!el.ownerDocument || !el.ownerDocument.defaultView) {\n    return null\n  }\n\n  try {\n    return el.ownerDocument.defaultView.frameElement\n  } catch (e) {\n    return null\n  }\n}\n\nfunction isHiddenByFrame (el: HTMLElement): boolean {\n  let frame = getFrameElement(el)\n  if (!frame) {\n    return false\n  }\n\n  return (\n    frame.clientHeight < el.scrollHeight || frame.clientWidth < el.scrollWidth\n  )\n}\n\nfunction alignNearest (\n  scrollingEdgeStart: number,\n  scrollingEdgeEnd: number,\n  scrollingSize: number,\n  scrollingBorderStart: number,\n  scrollingBorderEnd: number,\n  elementEdgeStart: number,\n  elementEdgeEnd: number,\n  elementSize: number\n) {\n  if (\n    (elementEdgeStart < scrollingEdgeStart &&\n      elementEdgeEnd > scrollingEdgeEnd) ||\n    (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)\n  ) {\n    return 0\n  }\n\n  if (\n    (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n    (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)\n  ) {\n    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart\n  }\n\n  if (\n    (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n    (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)\n  ) {\n    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd\n  }\n\n  return 0\n}\n","// @flow\n'use strict'\n\nimport CharacterRange from './characterRange';\nimport Refills from '../refills';\nimport rangeUtils from '../range-utils';\nimport { compute } from './compute';\nimport type { Options } from './compute';\n\ntype StandardBehaviorOptions = {|\n  ...Options;\n  behavior?: 'auto' | 'smooth';\n|}\nexport default class Highlight {\n  characterRange: CharacterRange;\n  refills: Refills;\n  applied: boolean = false;\n  range: Range;\n  constructor (characterRange: CharacterRange, refills: Refills) {\n    this.characterRange = characterRange;\n    this.refills = refills;\n  }\n\n  on (): void {\n    this.range = this.characterRange.toRange();\n    this.refills.appliesToRange(this.range);\n    this.applied = true;\n  }\n\n  off (): void {\n    this.range = this.characterRange.toRange();\n    this.refills.wipeToRange(this.range);\n    this.applied = false;\n  }\n\n  intersectsNode (node: Node): boolean {\n    const range = document.createRange();\n    range.selectNodeContents(node);\n\n    return rangeUtils.intersectsRange(this.characterRange.toRange(), range);\n  }\n\n  scrollIntoView (options?: StandardBehaviorOptions | boolean): void {\n    let behavior = typeof options === 'boolean' ? undefined : options?.behavior\n    compute(this.characterRange.toRange(), getOptions(options)).forEach(({ el, top, left }) => {\n      el.scrollTo({ top, left, behavior: behavior });\n    });\n  }\n\n  getText (): string {\n    return this.toRange().toString();\n  }\n\n  toRange (): Range {\n    return this.characterRange.toRange();\n  }\n}\n\nfunction getOptions (options?: any): Options {\n  if (options === false) {\n    return { block: 'end', inline: 'nearest' }\n  }\n\n  // $FlowIgnore\n  if (options === Object(options) && Object.keys(options).length !== 0) {\n    // $FlowIgnore\n    return options;\n  }\n\n  return { block: 'start', inline: 'nearest' }\n}\n","// @flow\n'use strict'\n\nimport Highlighter from '../../src/highlighter';\nconst cookieKey = 'highlights';\nconst highlighter = new Highlighter();\n\n// highlighter.deserialize([{ start: 20, end: 21, referenceNodeId: 'main' }]);\n\nif (checkACookieExists(cookieKey)) {\n  highlighter.deserialize(JSON.parse(geCookie(cookieKey)));\n}\n\ndocument.querySelector('.main')?.addEventListener('mouseup', () => {\n  const range = window.getSelection().getRangeAt(0);\n  if (range.toString() !== '' && !range.collapsed) {\n    highlighter.useSelection({ selection: window.getSelection().getRangeAt(0), referenceNodeId: 'main' });\n  }\n});\n\ndocument.getElementById('submit')?.addEventListener('click', () => {\n  const serialize = JSON.stringify(highlighter.serialize());\n  setCookie(cookieKey, serialize);\n  window.location.reload();\n});\n\nhighlighter.on('click', (highlight) => {\n  if (window.confirm('remove highlight ??')) {\n    highlighter.removeHighlight(highlight);\n    const serialize = JSON.stringify(highlighter.serialize());\n    setCookie(cookieKey, serialize);\n  }\n});\n\nfunction setCookie (key: string, value: string): void {\n  document.cookie = `${key}=${value}`;\n}\n\nfunction checkACookieExists (key: string): boolean {\n  return document.cookie.split(\";\").some((item) => item.trim().startsWith(`${key}=`));\n}\n\nfunction geCookie (key: string): string {\n  // $FlowIgnore\n  return document.cookie.split('; ').find((row) => row.startsWith(`${key}=`))?.split(\"=\")[1];\n}","// @flow\n'use strict'\n\nimport EventEmitter from './utils/eventEmitter';\nimport Refills from './refills';\nimport CharacterRange from './utils/characterRange';\nimport Highlight from './utils/highlight';\nimport rangeUtils from './range-utils';\nimport { createRefillsOptions } from './utils/createOptions';\nimport type { RefillsOptions, UseSelOptions, DefaultRefillsOptions, Serialize } from './types';\n\ntype EventMap = {|\n  click: (highlight: Highlight, el: HTMLElement, event: MouseEvent) => void;\n|}\n\nexport default class Highlighter extends EventEmitter<EventMap> {\n\n  refills: Refills;\n  highlights: Array<Highlight> = [];\n  options: DefaultRefillsOptions;\n  constructor (options?: RefillsOptions) {\n    super();\n    this.options = this.setOptions(options);\n  }\n\n  setOptions (options?: RefillsOptions = {}): DefaultRefillsOptions {\n    // $FlowIgnore\n    options = createRefillsOptions(options);\n    options.elProps = {\n      ...options.elProps,\n      // $FlowIgnore\n      onclick: this._handleHighlightClick.bind(this)\n    }\n    this.refills = new Refills(options);\n    // $FlowIgnore\n    return options;\n  }\n\n  _handleHighlightClick (event: MouseEvent) {\n    const el = event.target, highlight = this.getHighlightForElement(el);\n    this.emit('click', highlight, el, event);\n  }\n\n  getHighlightForElement (el: any): Highlight | null {\n    for (let i = 0, highlight; (highlight = this.highlights[i++]);) {\n      if (highlight.intersectsNode(el)) {\n        return highlight;\n      }\n    }\n\n    return null;\n  }\n\n  useSelection (useSelOptions?: UseSelOptions = {}): Highlight[] {\n    let highlights = [];\n    const sel = rangeUtils.getSelection(useSelOptions.selection),\n      referenceNode = getReferenceNode(useSelOptions.referenceNodeId);\n\n    if (referenceNode) {\n      const characterRanges = CharacterRange.fromSelection(sel, referenceNode);\n      highlights = this._useCharacterRanges(characterRanges);\n\n      restoreSelection(sel, characterRanges);\n    }\n\n    return highlights;\n  }\n  // $FlowIgnore\n  _useCharacterRanges (characterRanges: CharacterRange[]): Highlight[] {\n    const undoToHighligts: Highlight[] = [];\n\n    for (let i = 0, characterRange; (characterRange = characterRanges[i++]);) {\n      if (characterRange.isCollapsed) {\n        // ignore empty characterRange\n        continue;\n      }\n\n      let isEqual = false;\n      for (let j = 0, stockHighlight; (stockHighlight = this.highlights[j]); ++j) {\n\n        if (characterRange.isEqual(stockHighlight.characterRange)) {\n          isEqual = true;\n          continue;\n        }\n\n        if (characterRange.isIntersects(stockHighlight.characterRange) || characterRange.isAdjoin(stockHighlight.characterRange)) {\n          // $FlowIgnore\n          characterRange = characterRange.union(stockHighlight.characterRange);\n          undoToHighligts.push(stockHighlight);\n          this.highlights.splice(j--, 1);\n        }\n      }\n\n      if (!isEqual && characterRange) {\n        this.highlights.push(new Highlight(characterRange, this.refills));\n      }\n\n      undoToHighligts.forEach(highlight => {\n        if (highlight.applied) {\n          highlight.off();\n        }\n      });\n\n      const newHighlight: Highlight[] = [];\n      this.highlights.forEach(highlight => {\n        if (!highlight.applied) {\n          highlight.on();\n          newHighlight.push(highlight)\n        }\n      });\n\n      return newHighlight\n\n    }\n  }\n\n  unSelection (useSelOptions?: UseSelOptions = {}): Highlight[] {\n    let highlights = [];\n    const sel = rangeUtils.getSelection(useSelOptions.selection),\n      referenceNode = getReferenceNode(useSelOptions.referenceNodeId);\n\n    if (referenceNode) {\n      const characterRanges = CharacterRange.fromSelection(sel, referenceNode);\n      highlights = this._unCharacterRanges(characterRanges);\n\n      restoreSelection(sel, characterRanges);\n    }\n\n    return highlights;\n  }\n\n  _unCharacterRanges (characterRanges: CharacterRange[]): Highlight[] {\n    const undoToHighlights = [];\n\n    for (let i = 0, characterRange; (characterRange = characterRanges[i++]); ) {\n      if (characterRange.isCollapsed) {\n        continue;\n      }\n\n      for (let j = 0, stockHighlight; (stockHighlight = this.highlights[j]); ++j) {\n        if (characterRange.isIntersects(stockHighlight.characterRange)) {\n          const intersectionCr = characterRange.intersection(stockHighlight.characterRange);\n          if (intersectionCr) {\n            const complementCrs = stockHighlight.characterRange.complementarySet(intersectionCr);\n            complementCrs.forEach(complementCr => {\n              // add complement\n              this.highlights.push(new Highlight(complementCr, this.refills));\n            });\n            undoToHighlights.push(stockHighlight);\n            this.highlights.splice(j--, 1);\n          }\n        }\n      }\n    }\n\n    const unHighlights: Highlight[] = [];\n    undoToHighlights.forEach(highlight => {\n      if (highlight.applied) {\n        highlight.off();\n        unHighlights.push(highlight);\n      }\n    });\n\n    this.highlights.forEach(highlight => {\n      if (!highlight.applied) {\n        highlight.on();\n      }\n    });\n\n    return unHighlights;\n  }\n\n  removeHighlight (highlight: Highlight): void {\n    if (highlight instanceof Highlight) {\n      let highlights = this.highlights, index;\n      if ((index = highlights.indexOf(highlight)) > -1) {\n        if (highlight.applied) {\n          highlight.off();\n        }\n\n        highlights.splice(index, 1);\n      }\n    }\n  }\n\n  serialize (): Serialize[] {\n    return this.highlights.map(\n      highlight => ({\n        start: highlight.characterRange.start,\n        end: highlight.characterRange.end,\n        // $FlowIgnore\n        referenceNodeId: highlight.characterRange.referenceNode.id,\n        className: this.options.className,\n        text: highlight.getText()\n      })\n    );\n  }\n\n  deserialize (serialized: Serialize[]): void {\n    const highlights = [];\n    serialized.forEach(({ start, end, referenceNodeId }) => {\n      const referenceNode = getReferenceNode(referenceNodeId);\n      if (referenceNode) {\n        const highlight = new Highlight(new CharacterRange(start, end, referenceNode), this.refills);\n        highlight.on();\n        highlights.push(highlight);\n      }\n    });\n\n    this.highlights = highlights;\n  }\n\n}\n\nfunction getReferenceNode (id?: string): HTMLElement | null {\n  // $FlowIgnore\n  return document.getElementById(id) || document.body;\n}\n\nfunction restoreSelection (selection: Selection, characterRanges: CharacterRange[]): void {\n  selection.removeAllRanges();\n  characterRanges.forEach(characterRange => {\n    if (!characterRange.isCollapsed) {\n      selection.addRange(characterRange.toRange());\n    }\n  });\n}"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","apply","Function","EventEmitter","this","__events__","type","listener","data","push","once","self","on","off","arguments","__onceListener__","listeners","candidate","i","length","splice","args","l","Array","slice","isCharacterDataNode","node","t","nodeType","Node","TEXT_NODE","COMMENT_NODE","getNodeIndex","index","previousSibling","splitNode","ancestor","descendant","descendantOffset","newNode","offset","splitAtStart","parentNode","nextSibling","childNodes","cloneNode","hasAttribute","removeAttribute","child","newIndex","moveNode","newNodeIndex","removeNode","p","removeChild","appendChild","insertBefore","classListSupport","document","createElement","classList","classNameSupport","className","rnothtmlwhite","stripAndCollapse","match","join","classesToArray","isArray","toggleClass","el","classNames","ELEMENT_NODE","forEach","toggle","hasClass","removeClass","addClass","getClass","getAttribute","contains","indexOf","curClass","cur","final","add","setAttribute","isElement","remove","replace","findClosestAncestor","isAncestorOf","selfIsAncestor","n","isOrIsAncestorOf","findSelfOrAncestorWithClass","getNodeLength","crudNode","classes","getSelection","setRange","range","ec","eo","sc","so","len","setStart","setEnd","getIntersectionRange","rangeA","rangeB","intersectsRange","cloneRange","compareBoundaryPoints","START_TO_START","startContainer","startOffset","END_TO_END","endContainer","endOffset","start","END_TO_START","end","START_TO_END","RangeIterator","clonePartiallySelectedTextNodes","collapsed","root","commonAncestorContainer","_next","_end","current","_current","deleteData","createRange","iterateSubtree","it","cb","next","isPartiallySelectedSubtree","getSubtreeIterator","nit","createNodeIterator","nextNode","getNodes","nodeTypes","filter","regx","nodes","RegExp","test","toString","getEffectiveTextNodes","textNodes","rangeSelectsAnyText","textNode","textNodeRange","selectNodeContents","intersectionRange","sel","Selection","window","getRangesInSelection","selection","ranges","rangeCount","getRangeAt","intersection","rangeIterator","splitRangeBoundaries","startSameEnd","splitText","each","callback","createRefillsOptions","options","defaultOptions","tagName","elAttrs","elProps","normalize","propName","propValue","Refills","rangeUtils","domUtils","appliesToTextNode","lastTextNode","ancestorWithClass","splitBoundariesAncestorWithClass","wipeToAncestor","isEqualNode","firstChild","attrs","attrName","attrValue","mapAttrs","props","mapProps","isUndo","firstNode","lastNode","currentMerge","merges","rangeStartNode","rangeEndNode","rangeStartOffset","rangeEndOffset","precedingNode","getPrecedingMrTextNode","Merge","getLength","getNextMrTextNode","merge","getter","forward","adjacentPropName","position","checkParentElement","adjacentNode","adjacentNodeChild","firstTextNode","textParts","hasChildNodes","CharacterRange","referenceNode","isCollapsed","wrapRange","characterRanges","fromRange","characterRange","toRange","another","_createRelativeCharacterRange","isIntersects","isAdjoin","Math","min","max","collapse","nextCharIndex","nodeIterator","NodeFilter","SHOW_TEXT","charIndex","foundStart","foundEnd","canOverflow","overflow","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","style","getComputedStyle","overflowY","overflowX","frame","ownerDocument","defaultView","frameElement","e","getFrameElement","isHiddenByFrame","alignNearest","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","scrollingBorderStart","scrollingBorderEnd","elementEdgeStart","elementEdgeEnd","elementSize","Highlight","refills","appliesToRange","applied","wipeToRange","behavior","undefined","target","block","inline","scrollMode","scrollingElement","documentElement","frames","cursor","body","parentElement","viewportWidth","visualViewport","width","innerWidth","viewportHeight","height","innerHeight","scrollX","scrollY","getBoundingClientRect","targetHeight","targetWidth","targetTop","top","targetRight","right","targetBottom","bottom","targetLeft","left","targetBlock","targetInline","computations","frameStyle","borderLeft","parseInt","borderLeftWidth","borderTop","borderTopWidth","borderRight","borderRightWidth","borderBottom","borderBottomWidth","blockScroll","inlineScroll","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","scaleX","scaleY","scrollLeft","scrollTop","compute","keys","getOptions","scrollTo","getReferenceNode","id","getElementById","restoreSelection","removeAllRanges","addRange","cookieKey","highlighter","setOptions","onclick","_handleHighlightClick","bind","event","highlight","getHighlightForElement","emit","highlights","intersectsNode","useSelOptions","referenceNodeId","fromSelection","_useCharacterRanges","undoToHighligts","stockHighlight","isEqual","j","union","newHighlight","_unCharacterRanges","undoToHighlights","intersectionCr","complementarySet","complementCr","unHighlights","map","text","getText","serialized","setCookie","cookie","split","some","item","trim","startsWith","deserialize","JSON","parse","find","row","geCookie","querySelector","addEventListener","useSelection","serialize","stringify","location","reload","confirm","removeHighlight"],"sourceRoot":""}