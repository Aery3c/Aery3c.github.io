{"version":3,"file":"balanceRange.js","mappings":"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","sources":["webpack://highlighter/webpack/bootstrap","webpack://highlighter/webpack/runtime/define property getters","webpack://highlighter/webpack/runtime/hasOwnProperty shorthand","webpack://highlighter/webpack/runtime/make namespace object","webpack://highlighter/./src/dom-utils/isCharacterDataNode.js","webpack://highlighter/./src/dom-utils/getNodeIndex.js","webpack://highlighter/./src/dom-utils/crudNode.js","webpack://highlighter/./src/dom-utils/classes.js","webpack://highlighter/./src/dom-utils/findClosestAncestor.js","webpack://highlighter/./src/dom-utils/getNodeLength.js","webpack://highlighter/./src/range-utils/setRange.js","webpack://highlighter/./src/range-utils/intersection.js","webpack://highlighter/./src/range-utils/rangeIterator.js","webpack://highlighter/./src/dom-utils/index.js","webpack://highlighter/./src/range-utils/getNodes.js","webpack://highlighter/./src/range-utils/selection.js","webpack://highlighter/./src/range-utils/index.js","webpack://highlighter/./src/range-utils/splitRangeBoundaries.js","webpack://highlighter/./src/refills.js","webpack://highlighter/./src/utils/characterRange.js","webpack://highlighter/./src/utils/eventEmitter.js","webpack://highlighter/./examples/balanceRange/balanceRange.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// @flow\n'use strict'\n\nexport function isCharacterDataNode (node: Node | null): boolean {\n  if (!node) return false;\n  const t = node.nodeType;\n  return t === Node.TEXT_NODE || t === Node.COMMENT_NODE;\n}","// @flow\n'use strict'\n\nexport function getNodeIndex (node: Node): number {\n  let index = 0;\n  // $FlowIgnore\n  while ((node = node.previousSibling)) {\n    index++;\n  }\n\n  return index;\n}","// @flow\n'use strict'\nimport { isCharacterDataNode } from './isCharacterDataNode';\nimport { getNodeIndex } from './getNodeIndex';\n\nexport function splitNode (ancestor: any, descendant: any, descendantOffset: any): void {\n\n  let newNode, splitAtStart = (descendantOffset === 0);\n\n  if (isCharacterDataNode(descendant)) {\n    let index = getNodeIndex(descendant);\n\n    if (descendantOffset === 0) {\n      descendantOffset = index;\n\n    } else if (descendantOffset === descendant.data.length) {\n      descendantOffset = index + 1;\n    }\n    descendant = descendant.parentNode;\n  }\n\n  if (isSplitPoint(descendant, descendantOffset)) {\n    // clone empty node\n    newNode = descendant.cloneNode(false);\n    if (newNode.hasAttribute('id')) {\n      newNode.removeAttribute('id');\n    }\n    let child, newIndex = 0;\n    while ((child = descendant.childNodes[descendantOffset])) {\n      // move child to newNode\n      moveNode(child, newNode, newIndex++);\n    }\n    // move newNode to parentNode\n    moveNode(newNode, descendant.parentNode, getNodeIndex(descendant) + 1);\n  } else if (ancestor !== descendant) {\n    newNode = descendant.parentNode;\n\n    // Work out a new split point in the parent node\n    let newNodeIndex = getNodeIndex(descendant);\n\n    if (!splitAtStart) {\n      newNodeIndex++;\n    }\n    return splitNode(ancestor, newNode, newNodeIndex);\n  }\n}\n\nfunction isSplitPoint(node: Node, offset: number): boolean {\n  // Node.TEXT_NODE\n  if (isCharacterDataNode(node)) {\n    if (offset === 0) {\n      return !!node.previousSibling;\n      // $FlowIgnore\n    } else if (offset === node.length) {\n      return !!node.nextSibling;\n    } else {\n      return true;\n    }\n  }\n\n  // Node.ELEMENT_NODE\n  return offset > 0 && offset < node.childNodes.length;\n}\nexport function removeNode (node: Node): Node | null {\n  const p = node.parentNode;\n  if (p) {\n    return p.removeChild(node);\n  }\n\n  return null;\n}\n\nexport function moveNode (node: Node, newNode: Node, newIndex: number): void {\n  if (newIndex === -1) {\n    newIndex = newNode.childNodes.length;\n  }\n\n  if (newIndex === newNode.childNodes.length) {\n    newNode.appendChild(node);\n  } else {\n    newNode.insertBefore(node, newNode.childNodes[newIndex]);\n  }\n}","// @flow\n'use strict'\n\nconst classListSupport = !(typeof document.createElement('span').classList !== 'undefined');\nconst classNameSupport = !(typeof document.createElement('span').className !== 'undefined');\n\n// $FlowIgnore\nexport const rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\nexport function stripAndCollapse (value: string): string {\n  const tokens = value.match(rnothtmlwhite) || [];\n  return tokens.join(' ');\n}\n\n/**\n *\n * @param {string|Array} value\n * @return {string[]}\n */\nexport function classesToArray (value: string | Array<string>): string[] {\n  if (Array.isArray(value)) {\n    return value;\n  }\n  if (typeof value === 'string') {\n    return value.match(rnothtmlwhite) || [];\n  }\n  return [];\n}\n\n/**\n *\n * @param {HTMLElement} el\n * @param {string} value\n */\nexport function toggleClass (el: HTMLElement, value: string): boolean {\n  const classNames = classesToArray(value);\n\n  if (classNames.length && el.nodeType === Node.ELEMENT_NODE) {\n    classNames.forEach(className => {\n      if (classListSupport) {\n        el.classList.toggle(className);\n      } else {\n        if (hasClass(el, className)) {\n          removeClass(el, className);\n        } else {\n          addClass(el, className);\n        }\n      }\n    });\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n *\n * @param {HTMLElement} el\n * @return {string}\n */\nexport function getClass (el: HTMLElement): string {\n\n  if (el.nodeType !== Node.ELEMENT_NODE) {\n    return '';\n  }\n\n  if (classNameSupport) {\n    return el.className;\n  }\n\n  return el.getAttribute('class') || '';\n}\n\n/**\n *\n */\nexport function hasClass (el: HTMLElement, value: string): boolean {\n\n  if (el.nodeType !== Node.ELEMENT_NODE) {\n    return false;\n  }\n\n  if (classListSupport) {\n    return el.classList.contains(value);\n  }\n  const classNames = classesToArray(getClass(el));\n  return classNames.indexOf(value) > -1;\n}\n\n/**\n *\n * @param {HTMLElement | Node} el\n * @param {string} value\n */\nexport function addClass (el: HTMLElement, value: string): void {\n\n  let classNames = classesToArray(value), curClass, cur, final;\n\n  if (classNames.length && el.nodeType === Node.ELEMENT_NODE) {\n    if (classListSupport) {\n      el.classList.add(...classNames);\n    } else {\n      curClass = getClass(el);\n      cur = ' ' + stripAndCollapse(curClass) + ' ';\n      classNames.forEach(className => {\n        if (cur.indexOf(' ' + className + ' ') < 0) {\n          cur += className + ' '\n        }\n      });\n\n      final = stripAndCollapse(cur);\n\n      if (curClass !== final) {\n        if (classNameSupport) {\n          el.className = final;\n        } else {\n          el.setAttribute('class', final);\n        }\n      }\n    }\n  }\n}\n\n/**\n *\n * @param {HTMLElement | Node} el\n * @param {string} [value]\n */\nexport function removeClass (el: HTMLElement, value: string): void {\n\n  let classNames = classesToArray(value), curClass, cur, final,\n    isElement = (el.nodeType === Node.ELEMENT_NODE);\n\n  if (arguments.length < 2 && isElement) {\n    return el.removeAttribute('class');\n  }\n\n  if (classNames.length && isElement) {\n    if (classListSupport) {\n      el.classList.remove(...classNames);\n    } else {\n      curClass = getClass(el);\n      cur = ' ' + stripAndCollapse(curClass) + ' ';\n      classNames.forEach(className => {\n        while (cur.indexOf(' ' + className + ' ') > -1) {\n          cur = cur.replace(' ' + className + ' ', ' ');\n        }\n      });\n\n      final = stripAndCollapse(cur);\n      if (curClass !== final) {\n        if (classNameSupport) {\n          el.className = final;\n        } else {\n          el.setAttribute('class', final);\n        }\n      }\n    }\n  }\n}\n","// @flow\n'use strict'\n\nimport { hasClass } from './classes';\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} node\n * @return {Node | null}\n */\nexport function findClosestAncestor (ancestor: Node, node: Node): Node | null {\n  let p;\n  while (node) {\n    p = node.parentNode;\n    if (p === ancestor) {\n      return node\n    }\n    // $FlowIgnore\n    node = p;\n  }\n\n  return null;\n}\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} descendant\n * @param {boolean} selfIsAncestor\n */\nexport function isAncestorOf (ancestor: Node, descendant: Node, selfIsAncestor: boolean): boolean {\n  let n = selfIsAncestor ? descendant : descendant.parentNode;\n  while (n) {\n    if (n === ancestor) {\n      return true;\n    } else {\n      n = n.parentNode;\n    }\n  }\n  return false;\n}\n\n/**\n *\n * @param {Node} ancestor\n * @param {Node} descendant\n * @return {boolean}\n */\nexport function isOrIsAncestorOf(ancestor: Node, descendant: Node): boolean {\n  return isAncestorOf(ancestor, descendant, true);\n}\n\nexport function findSelfOrAncestorWithClass (node: Node, className: string): Node | null {\n  while (node) {\n    // $FlowIgnore\n    if (hasClass(node, className)) {\n      return node;\n    }\n    // $FlowIgnore\n    node = node.parentNode;\n  }\n  return null;\n}\n\n","// @flow\n'use strict'\n\n/**\n * The element node returns the child node length, and the text node returns the text length\n * @param {Node|Text} node\n */\n\nimport { isCharacterDataNode } from './isCharacterDataNode';\n\nexport function getNodeLength (node: Node): number {\n  const t = node.nodeType;\n  if (t === Node.ELEMENT_NODE) {\n    return node.childNodes.length;\n  } else if (isCharacterDataNode(node)) {\n    // $FlowIgnore\n    return node.length;\n  }\n  return 0;\n}","// @flow\n'use strict'\nimport { getNodeLength } from '../dom-utils/getNodeLength';\n\nexport function setRange (range: Range, ...args: Array<any>) {\n  let sc = args[0], so = args[1], ec, eo;\n  const len = getNodeLength(sc);\n\n  switch (args.length) {\n    case 2:\n      ec = sc;\n      eo = len;\n      break;\n    case 3:\n      ec = args[2];\n      eo = so;\n      break;\n    case 4:\n      ec = args[2];\n      eo = args[3];\n      break;\n  }\n\n  range.setStart(sc, so);\n  // $FlowIgnore\n  range.setEnd(ec, eo);\n}\n","// @flow\n'use strict'\n\n/**\n * Returns the part of a specified range that intersects another range\n */\nexport function getIntersectionRange (rangeA: Range, rangeB: Range): Range | null {\n  if (intersectsRange(rangeA, rangeB)) {\n    const range = rangeA.cloneRange();\n    // $FlowIgnore\n    if (range.compareBoundaryPoints(rangeB.START_TO_START, rangeB) === -1) {\n      range.setStart(rangeB.startContainer, rangeB.startOffset);\n    }\n    // $FlowIgnore\n    if (range.compareBoundaryPoints(rangeB.END_TO_END, rangeB) === 1) {\n      range.setEnd(rangeB.endContainer, rangeB.endOffset);\n    }\n\n    return range;\n  }\n\n  return null;\n}\n\n/**\n * Returns a boolean indicating whether the given Range intersects the Range.\n */\nexport function intersectsRange (rangeA: Range, rangeB: Range): boolean {\n  // rangeA.s < rangeB.e;\n  // $FlowIgnore\n  const start = rangeA.compareBoundaryPoints(rangeB.END_TO_START, rangeB);\n  // rangeA.e > rangeB.s;\n  // $FlowIgnore\n  const end = rangeA.compareBoundaryPoints(rangeB.START_TO_END, rangeB);\n\n  return start < 0 && end > 0;\n}","// @flow\n'use strict'\n\nimport { isCharacterDataNode } from '../dom-utils/isCharacterDataNode';\nimport { findClosestAncestor, isOrIsAncestorOf } from '../dom-utils/findClosestAncestor';\nimport { getNodeLength } from '../dom-utils/getNodeLength';\nimport { setRange } from './setRange';\n\nexport class RangeIterator {\n  range: Range;\n  clonePartiallySelectedTextNodes: boolean;\n  root: Node;\n  sc: Node;\n  so: number;\n  ec: Node;\n  eo: number;\n  _current: Node | null = null;\n  _end: Node | null = null;\n  _next: Node | null = null;\n  constructor(range: Range, clonePartiallySelectedTextNodes?: boolean = false) {\n    this.range = range;\n    this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n    if (!this.range.collapsed) {\n      this.root = this.range.commonAncestorContainer;\n      this.sc = this.range.startContainer;\n      this.so = this.range.startOffset;\n      this.ec = this.range.endContainer;\n      this.eo = this.range.endOffset;\n\n      if (this.sc === this.ec && isCharacterDataNode(this.sc)) {\n        this._next = this._end = this.sc;\n      } else {\n        this._next = this.sc === this.root && !isCharacterDataNode(this.sc)\n          ? this.sc.childNodes[this.so] : findClosestAncestor(this.root, this.sc)\n\n        this._end = this.ec === this.root && !isCharacterDataNode(this.ec)\n          ? this.ec.childNodes[this.eo - 1] : findClosestAncestor(this.root, this.ec);\n      }\n    }\n\n  }\n  next (): Node | null {\n    let current = this._current = this._next;\n    // $FlowIgnore\n    this._next = this._current != null && this._current !== this._end ? this._current.nextSibling : null;\n\n    // Check for partially selected text nodes\n    if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n      // clone partially selected text nodes\n      // return cloneNode\n      if (current === this.ec) {\n        // $FlowIgnore\n        (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n      }\n\n      if (current === this.sc) {\n        // $FlowIgnore\n        (current = current.cloneNode(true)).deleteData(0, this.so);\n      }\n    }\n\n    return current;\n  }\n\n  isPartiallySelectedSubtree (): boolean {\n    return !isCharacterDataNode(this._current) &&\n      // $FlowIgnore\n      (isOrIsAncestorOf(this._current, this.sc) || isOrIsAncestorOf(this._current, this.ec));\n  }\n\n  getSubtreeIterator (): RangeIterator {\n    const range = document.createRange(), current = this._current;\n    // $FlowIgnore\n    let startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);\n\n    if (current) {\n      if (isOrIsAncestorOf(current, this.sc)) {\n        startContainer = this.sc;\n        startOffset = this.so;\n      }\n      if (isOrIsAncestorOf(current, this.ec)) {\n        endContainer = this.ec;\n        endOffset = this.eo;\n      }\n    }\n\n    setRange(range, startContainer, startOffset, endContainer, endOffset);\n\n    return new RangeIterator(range, this.clonePartiallySelectedTextNodes);\n  }\n}\n\nexport function iterateSubtree (it: RangeIterator, cb: (node: Node) => void) {\n  let node;\n  while((node = it.next())) {\n    if (it.isPartiallySelectedSubtree()) {\n      const subIt = it.getSubtreeIterator();\n      iterateSubtree(subIt, cb);\n    } else {\n      const nit = document.createNodeIterator(node);\n      while((node = nit.nextNode())) {\n        cb(node);\n      }\n    }\n  }\n}","// @flow\n\nimport * as crudNode from './crudNode';\nimport * as classes from './classes';\nimport * as findClosestAncestor from './findClosestAncestor';\nimport { isCharacterDataNode } from './isCharacterDataNode';\nimport { getNodeIndex } from './getNodeIndex';\nimport { getNodeLength } from './getNodeLength';\n\nexport default {\n  ...crudNode,\n  ...classes,\n  ...findClosestAncestor,\n  isCharacterDataNode,\n  getNodeIndex,\n  getNodeLength,\n  getSelection\n};","// @flow\n'use strict'\n\nimport { RangeIterator, iterateSubtree } from './rangeIterator';\nimport { getIntersectionRange } from './intersection';\n\nexport function getNodes (range: Range, nodeTypes?: Array<number>, filter?: (node: Node) => boolean): Node[] {\n  let nodes = [], regx;\n  if (nodeTypes && nodeTypes.length) {\n    regx = new RegExp(`(${nodeTypes.join('|')})$`);\n  }\n\n  iterateSubtree(new RangeIterator(range, false), (node) => {\n    if (regx && !regx.test(node.nodeType.toString())) {\n      return;\n    }\n\n    if (typeof filter == 'function' && !filter(node)) {\n      return;\n    }\n\n    nodes.push(node);\n  });\n\n  return nodes;\n}\n\n/**\n * range (prev/next) point (last/first)\n * @param range\n */\nexport function getEffectiveTextNodes (range: Range): Node[] {\n  const textNodes = getNodes(range, [Node.TEXT_NODE]);\n\n  let start = 0, end = textNodes.length, node;\n\n  // remove invalid text nodes from left to right\n  while ((node = textNodes[start]) && !rangeSelectsAnyText(range, node)) {\n    ++start;\n  }\n\n  // remove invalid text nodes from right to left\n  while ((node = textNodes[end - 1]) && !rangeSelectsAnyText(range, node)) {\n    --end;\n  }\n\n  return textNodes.slice(start, end);\n}\n\n\nfunction rangeSelectsAnyText(range: Range, textNode: Node): boolean {\n  const textNodeRange = document.createRange();\n  textNodeRange.selectNodeContents(textNode);\n  const intersectionRange = getIntersectionRange(textNodeRange, range);\n  const text = intersectionRange ? intersectionRange.toString() : '';\n  return text !== '';\n}\n","// @flow\n'use strict'\n\nexport function getSelection (sel?: any): Selection {\n  if (sel instanceof Selection) {\n    return sel;\n  }\n\n  return window.getSelection();\n}\n\nexport function getRangesInSelection (selection: Selection): Range[] {\n  const ranges = [];\n  for (let i = 0; i < selection.rangeCount; ++i) {\n    ranges.push(selection.getRangeAt(i));\n  }\n\n  return ranges;\n}","// @flow\n'use strict'\nimport { setRange } from './setRange';\nimport * as intersection from './intersection';\nimport * as getNodes from './getNodes';\nimport * as rangeIterator from './rangeIterator';\nimport { splitRangeBoundaries } from './splitRangeBoundaries';\nimport * as selection from './selection';\n\nexport default {\n  ...intersection,\n  ...getNodes,\n  ...rangeIterator,\n  ...selection,\n  splitRangeBoundaries,\n  setRange\n}","// @flow\n'use strict'\n\nimport { isCharacterDataNode } from '../dom-utils/isCharacterDataNode';\nimport { getNodeIndex } from '../dom-utils/getNodeIndex';\n\nexport function splitRangeBoundaries (range: Range): void {\n  let [sc, so, ec, eo] = [range.startContainer, range.startOffset, range.endContainer, range.endOffset];\n  const startSameEnd: boolean = (sc === ec);\n  // $FlowIgnore\n  if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n    // $FlowIgnore\n    ec.splitText(eo);\n  }\n  // $FlowIgnore\n  if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n    // $FlowIgnore\n    sc = sc.splitText(so);\n    if (startSameEnd) {\n      eo -= so;\n      ec = sc;\n    } else if (ec === sc.parentNode && eo <= getNodeIndex(sc)) {\n      eo++;\n    }\n    so = 0;\n  }\n}","// @flow\n'use strict'\n\nimport type { RefillsOptions, DefaultRefillsOptions } from './types';\nimport domUtils from './dom-utils';\nimport rangeUtils from './range-utils';\nimport { createRefillsOptions } from './utils/createOptions';\nimport { each } from './utils/each';\n\nexport default class Refills {\n  options: DefaultRefillsOptions;\n  constructor(options?: RefillsOptions) {\n    this.options = createRefillsOptions(options);\n  }\n\n  appliesToRange (range: Range): void {\n    rangeUtils.splitRangeBoundaries(range);\n\n    const textNodes = rangeUtils.getEffectiveTextNodes(range);\n    if (textNodes.length) {\n      textNodes.forEach(textNode => {\n        if (this.options.className && !domUtils.findSelfOrAncestorWithClass(textNode, this.options.className)) {\n          this.appliesToTextNode(textNode);\n        }\n      });\n\n      const lastTextNode = textNodes[textNodes.length - 1];\n      // $FlowIgnore\n      rangeUtils.setRange(range, textNodes[0], 0, lastTextNode, lastTextNode.length);\n      if (this.options.normalize) {\n        this.normalize(textNodes, range, false);\n      }\n    }\n  }\n\n  appliesToTextNode (textNode: Node): void {\n    const parentNode = textNode.parentNode;\n    if (textNode.nodeType === Node.TEXT_NODE && parentNode) {\n      const el = this.createElement();\n      if (el) {\n        parentNode.insertBefore(el, textNode);\n        el.appendChild(textNode);\n      }\n    }\n  }\n\n  wipeToRange (range: Range): void {\n    rangeUtils.splitRangeBoundaries(range);\n\n    const textNodes = rangeUtils.getEffectiveTextNodes(range);\n\n    if (textNodes.length) {\n      // split boundaries ancestor with class\n      splitBoundariesAncestorWithClass(range, this.options.className);\n      textNodes.forEach(textNode => {\n        let ancestorWithClass = domUtils.findSelfOrAncestorWithClass(textNode, this.options.className);\n        if (ancestorWithClass) {\n          this.wipeToAncestor(ancestorWithClass);\n        }\n      });\n\n      const lastTextNode = textNodes[textNodes.length - 1];\n      // $FlowIgnore\n      rangeUtils.setRange(range, textNodes[0], 0, lastTextNode, lastTextNode.length);\n      if (this.options.normalize) {\n        this.normalize(textNodes, range, true);\n      }\n    }\n  }\n\n  wipeToAncestor (ancestor: any): void {\n    if (this.isEqualNode(ancestor)) {\n      let child, index = domUtils.getNodeIndex(ancestor);\n      const parentNode = ancestor.parentNode;\n\n      while ((child = ancestor.firstChild)) {\n        // move children to sibling\n        domUtils.moveNode(child, parentNode, index++);\n      }\n\n      domUtils.removeNode(ancestor);\n    } else {\n      domUtils.removeClass(ancestor, this.options.className);\n    }\n  }\n\n  createElement (): HTMLElement | null {\n    if (this.options.tagName) {\n      const el = document.createElement(this.options.tagName);\n      if (this.options.className && this.options.elAttrs && this.options.elProps) {\n        domUtils.addClass(el, this.options.className);\n        // $FlowIgnore\n        mapAttrs(el, this.options.elAttrs);\n        // $FlowIgnore\n        mapProps(el, this.options.elProps);\n      }\n      return el;\n    }\n\n    return null;\n  }\n\n  normalize (textNodes: Node[], range: Range, isUndo: boolean): void {\n    let firstNode = textNodes[0], lastNode = textNodes[textNodes.length - 1];\n\n    let currentMerge = null, merges = [];\n\n    let rangeStartNode = firstNode, rangeEndNode = lastNode;\n    // $FlowIgnore\n    let rangeStartOffset = 0, rangeEndOffset = lastNode.length;\n\n    textNodes.forEach(textNode => {\n      // go through each textNode and find the mergable node in front of them,\n      const precedingNode = getPrecedingMrTextNode(textNode, !isUndo, (node) => {\n        return this.isEqualNode(node);\n      });\n\n      if (precedingNode) {\n        // create a Merge object headed by precedingNode\n        if (currentMerge == null) {\n          currentMerge = new Merge(precedingNode);\n          merges.push(currentMerge);\n        }\n        // $FlowIgnore\n        currentMerge.textNodes.push(textNode);\n\n        if (rangeStartNode === textNode) {\n          // $FlowIgnore\n          rangeStartNode = currentMerge.textNodes[0];\n          // $FlowIgnore\n          rangeStartOffset = rangeStartNode.length;\n        }\n\n        if (rangeEndNode === textNode) {\n          // $FlowIgnore\n          rangeEndNode = currentMerge.textNodes[0];\n          // $FlowIgnore\n          rangeEndOffset = currentMerge.getLength();\n        }\n\n      } else {\n        // reset the current Merge object to create a new merge\n        currentMerge = null;\n      }\n    });\n\n    const nextNode = getNextMrTextNode(lastNode, !isUndo, (node) => {\n      return this.isEqualNode(node);\n    });\n\n    if (nextNode) {\n      if (currentMerge == null) {\n        currentMerge = new Merge(lastNode);\n        merges.push(currentMerge);\n      }\n      // $FlowIgnore\n      currentMerge.textNodes.push(nextNode);\n    }\n\n    if (merges.length) {\n      merges.forEach(merge => merge.start());\n\n      rangeUtils.setRange(range, rangeStartNode, rangeStartOffset, rangeEndNode, rangeEndOffset);\n    }\n  }\n\n  isEqualNode (node: Node): boolean {\n    const newNode = this.createElement();\n    if (newNode) {\n      return newNode.cloneNode(false).isEqualNode(node.cloneNode(false));\n    }\n    return false;\n  }\n}\n\nfunction mapAttrs (el: HTMLElement, attrs: Object) {\n  each(attrs, function (attrName, attrValue) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (attrs.hasOwnProperty(attrName) && !/^class(?:Name)?$/i.test(attrName)) {\n      el.setAttribute(attrName, attrValue);\n    }\n  });\n}\n\nfunction mapProps (el: HTMLElement, props: Object) {\n  each(props, function (propName, propValue) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (props.hasOwnProperty(propName)) {\n      if (propName === 'className') {\n        domUtils.addClass(el, propValue);\n      } else {\n        // $FlowIgnore\n        el[propName] = propValue;\n      }\n    }\n  });\n}\n\nconst getPrecedingMrTextNode = getter(false);\n\nconst getNextMrTextNode = getter(true);\nfunction getter (forward: boolean): ((textNode: Node, checkParentElement: boolean, filter?: (node: Node) => boolean) => Node | null) {\n  const adjacentPropName = forward ? 'nextSibling' : 'previousSibling';\n  const position = forward ? 'firstChild' : 'lastChild';\n  return function (textNode, checkParentElement, filter) {\n    // $FlowIgnore\n    let adjacentNode = textNode[adjacentPropName], parentNode = textNode.parentNode;\n\n    if (adjacentNode && adjacentNode.nodeType === Node.TEXT_NODE) {\n      return adjacentNode\n    } else if (checkParentElement) {\n      // $FlowIgnore\n      adjacentNode = parentNode[adjacentPropName];\n      if (adjacentNode && adjacentNode.nodeType === Node.ELEMENT_NODE) {\n        if (filter && !filter(adjacentNode)) {\n          return null;\n        }\n        let adjacentNodeChild = adjacentNode[position];\n        if (adjacentNodeChild && adjacentNodeChild.nodeType === Node.TEXT_NODE) {\n          return adjacentNodeChild\n        }\n      }\n    }\n\n    return null\n  }\n}\n\nfunction splitBoundariesAncestorWithClass (range: Range, className: string): void {\n  [{ node: range.endContainer, offset: range.endOffset }, { node: range.startContainer, offset: range.startOffset }]\n    .forEach(({ node, offset }) => {\n      const ancestorWithClass = domUtils.findSelfOrAncestorWithClass(node, className);\n      if (ancestorWithClass) {\n        domUtils.splitNode(ancestorWithClass, node, offset);\n      }\n    });\n}\n\nclass Merge {\n  firstTextNode: Node;\n  textNodes: Node[];\n  constructor(node: Node) {\n    const n = node.nodeType === Node.ELEMENT_NODE ? node.firstChild : node;\n    if (n) {\n      this.firstTextNode = n;\n      this.textNodes = [n];\n    }\n  }\n\n  start (): string {\n    const textParts = [];\n    this.textNodes.forEach((textNode, index) => {\n      const parentNode = textNode.parentNode;\n      if (index > 0 && parentNode) {\n        domUtils.removeNode(textNode);\n        if (!parentNode.hasChildNodes()) {\n          domUtils.removeNode(parentNode);\n        }\n      }\n      // $FlowIgnore\n      textParts.push(textNode.data);\n    });\n    // $FlowIgnore\n    this.firstTextNode.data = textParts.join('');\n    return this.firstTextNode.data;\n  }\n\n  getLength (): number {\n    let len = 0;\n    this.textNodes.forEach(textNode => {\n      // $FlowIgnore\n      len += textNode.length;\n    });\n    return len;\n  }\n}","// @flow\n'use strict'\nimport rangeUtils from '../range-utils';\n\nexport default class CharacterRange {\n\n  start: number;\n  end: number;\n  referenceNode: Node;\n  isCollapsed: boolean;\n  constructor(start: number, end: number, referenceNode: Node) {\n    this.start = start;\n    this.end = end;\n    this.referenceNode = referenceNode;\n    this.isCollapsed = this.start === this.end;\n  }\n\n  _createRelativeCharacterRange (characterRange: CharacterRange): CharacterRange {\n    if (characterRange.referenceNode !== this.referenceNode) {\n      return CharacterRange.fromRange(characterRange.toRange(), this.referenceNode);\n    }\n\n    return characterRange;\n  }\n  isEqual (another: CharacterRange): boolean {\n    another = this._createRelativeCharacterRange(another);\n    return this.start === another.start && this.end === another.end;\n  }\n\n  isIntersects (another: CharacterRange): boolean {\n    another = this._createRelativeCharacterRange(another);\n    return this.start < another.end && this.end > another.start;\n  }\n\n  isAdjoin (another: CharacterRange): boolean {\n    another = this._createRelativeCharacterRange(another);\n    return this.start === another.end || this.end === another.start\n  }\n\n  union (another: CharacterRange): CharacterRange | null {\n    another = this._createRelativeCharacterRange(another);\n    if (this.isIntersects(another) || this.isAdjoin(another)) {\n      return new CharacterRange(Math.min(this.start, another.start), Math.max(this.end, another.end), this.referenceNode);\n    }\n    return null\n  }\n\n  intersection (another: CharacterRange): CharacterRange | null {\n    another = this._createRelativeCharacterRange(another);\n    if (this.isIntersects(another)) {\n      return new CharacterRange(Math.max(this.start, another.start), Math.min(this.end, another.end), this.referenceNode);\n    }\n\n    return null;\n  }\n\n  complementarySet (another: CharacterRange): CharacterRange[] {\n    const characterRanges = [];\n    another = this._createRelativeCharacterRange(another);\n\n    if (this.start < another.start) {\n      characterRanges.push(new CharacterRange(this.start, another.start, this.referenceNode));\n    }\n\n    if (this.end > another.end) {\n      characterRanges.push(new CharacterRange(another.end, this.end, this.referenceNode));\n    }\n\n    return characterRanges;\n  }\n\n  toRange (): Range {\n    const range = document.createRange();\n    const { start, end } = this;\n    range.setStart(this.referenceNode, 0);\n    range.collapse(true);\n\n    const nodeIterator = document.createNodeIterator(this.referenceNode, NodeFilter.SHOW_TEXT);\n    let textNode, charIndex = 0, nextCharIndex;\n\n    let foundStart = false, foundEnd = false;\n    while (!foundEnd && (textNode = nodeIterator.nextNode()) && textNode) {\n      nextCharIndex = charIndex + textNode.length;\n      if (!foundStart && start >= charIndex && start <= nextCharIndex) {\n        range.setStart(textNode, start - charIndex);\n        foundStart = true;\n      }\n\n      if (end >= charIndex && end <= nextCharIndex) {\n        range.setEnd(textNode, end - charIndex);\n        foundEnd = true;\n      }\n      charIndex = nextCharIndex;\n    }\n\n    return range;\n  }\n  static fromRange (range: Range, referenceNode: Node): CharacterRange {\n    const wrapRange = range.cloneRange();\n    wrapRange.selectNodeContents(referenceNode);\n\n    const intersectionRange = rangeUtils.getIntersectionRange(wrapRange, range);\n    let start = 0, end = 0;\n    if (intersectionRange) {\n      wrapRange.setEnd(intersectionRange.startContainer, intersectionRange.startOffset);\n      start = wrapRange.toString().length;\n      end = start + intersectionRange.toString().length\n    }\n\n    return new CharacterRange(start, end, referenceNode);\n\n  }\n  static fromSelection (sel: Selection, referenceNode: HTMLElement | Node): CharacterRange[] {\n    const characterRanges = []\n    rangeUtils.getRangesInSelection(sel).forEach(range => {\n      characterRanges.push(CharacterRange.fromRange(range, referenceNode));\n    });\n\n    return characterRanges;\n  }\n}","// @flow\n/* global $Values */\n'use strict'\n\ntype Listener = (...args: Array<any>) => void;\ntype ListenerMap = { [key: string]: Listener };\nconst apply = Function.prototype.apply, call = Function.prototype.call;\nexport default class EventEmitter<U: ListenerMap> {\n  __events__: Object;\n  constructor() {\n    this.__events__ = {};\n  }\n\n  on<T: string> (type: T, listener: $Values<U>): EventEmitter<U> {\n    const data = this.__events__;\n    if (!data[type]) data[type] = listener;\n    else if (typeof data[type] === 'object') data[type].push(listener);\n    else data[type] = [data[type], listener];\n\n    return this;\n  }\n\n  once<T: string> (type: T, listener: $Values<U>): EventEmitter<U> {\n    let once, self;\n\n    self = this;\n    // $FlowIgnore\n    self.on.call(self, type, once = function () {\n      // $FlowIgnore\n      self.off.call(self, type, once);\n      apply.call(listener, self, arguments);\n    });\n    // $FlowIgnore\n    once.__onceListener__ = listener;\n    return this;\n  }\n\n  off<T: string> (type: T, listener: $Values<U>): EventEmitter<U> {\n    const data = this.__events__;\n    if (!data[type]) return this;\n\n    const listeners = data[type];\n\n    if (typeof listeners === 'object') {\n      for (let i = 0, candidate; (candidate = listeners[i]); ++i) {\n        if ((candidate === listener) ||\n          (candidate.__onceListener__ === listener)) {\n          if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n          else listeners.splice(i, 1);\n        }\n      }\n    } else {\n      if ((listeners === listener) ||\n        (listeners.__onceListener__ === listener)) {\n        delete data[type];\n      }\n    }\n\n    return this;\n  }\n\n  emit<T: string> (type: T, ...args: Array<any>): void {\n    let listeners = this.__events__[type];\n    if (!listeners) return;\n\n    let l, i;\n\n    if (typeof listeners === 'object') {\n      l = arguments.length;\n      args = new Array(l - 1);\n      for (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n      listeners = listeners.slice();\n      for (let i = 0, listener; (listener = listeners[i]); ++i) {\n        apply.call(listener, this, args);\n      }\n    } else {\n      switch (arguments.length) {\n        case 1:\n          call.call(listeners, this);\n          break;\n        case 2:\n          call.call(listeners, this, arguments[1]);\n          break;\n        case 3:\n          call.call(listeners, this, arguments[1], arguments[2]);\n          break;\n        default:\n          l = arguments.length;\n          args = new Array(l - 1);\n          for (i = 1; i < l; ++i) {\n            args[i - 1] = arguments[i];\n          }\n          apply.call(listeners, this, args);\n      }\n    }\n  }\n}","/**\n * when two Character ranges have different reference nodes.\n *\n */\n\n// @flow\n'use strict'\n\nimport { CharacterRange } from '../../src';\n\nconst p = document.getElementById('p');\nconst span = document.getElementById('span');\nconst start = 0, end = 9;\nconst body = document.body;\nif (p && span && body) {\n  const c1 = new CharacterRange(start, end, p);\n  const c2 = new CharacterRange(start, end, span);\n\n  console.log(CharacterRange.fromRange(c1.toRange(), body));\n  console.log(CharacterRange.fromRange(c2.toRange(), body));\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","isCharacterDataNode","node","t","nodeType","Node","TEXT_NODE","COMMENT_NODE","getNodeIndex","index","previousSibling","splitNode","ancestor","descendant","descendantOffset","newNode","offset","splitAtStart","data","length","parentNode","nextSibling","childNodes","cloneNode","hasAttribute","removeAttribute","child","newIndex","moveNode","newNodeIndex","removeNode","p","removeChild","appendChild","insertBefore","classListSupport","document","createElement","classList","classNameSupport","className","rnothtmlwhite","stripAndCollapse","match","join","classesToArray","Array","isArray","toggleClass","el","classNames","ELEMENT_NODE","forEach","toggle","hasClass","removeClass","addClass","getClass","getAttribute","contains","indexOf","curClass","cur","final","add","setAttribute","isElement","arguments","remove","replace","findClosestAncestor","isAncestorOf","selfIsAncestor","n","isOrIsAncestorOf","findSelfOrAncestorWithClass","getNodeLength","setRange","range","ec","eo","sc","so","len","setStart","setEnd","getIntersectionRange","rangeA","rangeB","intersectsRange","cloneRange","compareBoundaryPoints","START_TO_START","startContainer","startOffset","END_TO_END","endContainer","endOffset","start","END_TO_START","end","START_TO_END","crudNode","classes","getSelection","RangeIterator","clonePartiallySelectedTextNodes","this","collapsed","root","commonAncestorContainer","_next","_end","current","_current","deleteData","createRange","iterateSubtree","it","cb","next","isPartiallySelectedSubtree","getSubtreeIterator","nit","createNodeIterator","nextNode","getNodes","nodeTypes","filter","regx","nodes","RegExp","test","toString","push","getEffectiveTextNodes","textNodes","rangeSelectsAnyText","slice","textNode","textNodeRange","selectNodeContents","intersectionRange","sel","Selection","window","getRangesInSelection","selection","ranges","i","rangeCount","getRangeAt","intersection","rangeIterator","splitRangeBoundaries","startSameEnd","splitText","getter","forward","adjacentPropName","position","checkParentElement","adjacentNode","adjacentNodeChild","Function","apply","CharacterRange","referenceNode","isCollapsed","wrapRange","rangeUtils","characterRanges","fromRange","characterRange","toRange","another","_createRelativeCharacterRange","isIntersects","isAdjoin","Math","min","max","collapse","nextCharIndex","nodeIterator","NodeFilter","SHOW_TEXT","charIndex","foundStart","foundEnd","getElementById","span","body","c1","c2","console","log"],"sourceRoot":""}